<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <title>System cofania</title>
  <meta name="topic-status" content="Draft" />
  <link rel="stylesheet" type="text/css" href="../../../assets/css/default.css" />
  <script src="../../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Gurpreet S. Matharoo" />
  <meta name="topic-comment" content="Details for Rollback Multiplayer" />
  <meta name="template" content="../../../assets/masterpages/Manual_Page.htt" />
  <meta name="condition-tags" content="Export:Beta" />
</head>
<body>
  <h1>System cofania</h1>
  <p>Po zapoznaniu się z tutorialem <a data-xref="{title}" href="Creating_Multiplayer.htm">Tworzenie gry wieloosobowej</a> możesz mieć pewne pytania dotyczące działania systemu cofania. Ta strona ma na celu wyjaśnienie tych kwestii.</p>
  <h2>Co to jest cofanie?</h2>
  <p>Podczas gry w sieci łatwo o opóźnienia. Jeśli grasz z kimś zdalnie, dotarcie do Ciebie może zająć ułamek sekundy, ale nawet to może zepsuć wrażenia z gry.</p>
  <p>Funkcja cofania wykorzystuje przewidywania, aby zmniejszyć efekt opóźnienia. W oparciu o poprzednie dane wejściowe przewiduje, co zamierza zrobić inny użytkownik, i pokazuje wynik tego przewidywania. Jeśli przewidywanie jest poprawne, nie odczuwasz dużego opóźnienia, a gra jest znacznie bardziej responsywna.</p>
  <p>Gdy system otrzymuje informacje od zdalnego gracza i zdaje sobie sprawę, że jego przewidywania były błędne, cofa się o określoną liczbę klatek, aby osiągnąć prawidłowy stan, i ponownie uruchamia swoje przewidywania od tego momentu. Dlatego właśnie nazywa się to &quot;Rollback multiplayer&quot;.</p>
  <p>System gry wieloosobowej GameMakera obraca się wokół tego, ponieważ nieustannie synchronizuje stan wszystkich graczy, dokonuje przewidywań, aby zmniejszyć opóźnienia, i w razie potrzeby cofa się, aby uruchomić przewidywania z właściwego stanu.</p>
  <h2 id="h2">Obiekty zarządzane</h2>
  <p>Obiekty mają pole wyboru &quot;<strong>Zarządzane</strong>&quot;, które jest domyślnie włączone dla nowych stron <span class="notranslate">objects</span>:</p>
  <p><img>Obiekty oznaczone jako zarządzane mogą być cofane i mogą być na nich uruchamiane predykcje, w tym wszystkie ich zmienne, tworzenie i niszczenie.</p>
  <p>Wszystkie strony <span class="notranslate">objects</span>, które są częścią rozgrywki, takie jak gracz, menedżer/kontroler <span class="notranslate">objects</span>, podnośniki przedmiotów, pociski itp. muszą być oznaczone jako zarządzane.</p>
  <p>Możesz wyłączyć tę funkcję w przypadku stron <span class="notranslate">objects</span>, które nie muszą być synchronizowane między graczami, takich jak statyczny świat <span class="notranslate">objects</span>, wizualizacje, efekty itp. niewpływające w żaden sposób na rozgrywkę.</p>
  <h2 id="h">Test synchronizacji</h2>
  <p><span class="inline"><a href="Rollback_Functions/rollback_create_game.htm">rollback_create_game()</a></span> przyjmuje argument Test synchronizacji, który jest domyślnie włączony (jeśli argument nie zostanie podany).</p>
  <p>Test synchronizacji służy do testowania gry w trybie offline. Jeśli wystąpią jakiekolwiek problemy z synchronizacją, informuje o tym, drukując błąd w dzienniku wyjściowym. Z programu Sync Test można korzystać na stronach <span class="notranslate">Windows</span>, macOS i Opera GX.</p>
  <p>Podczas testu synchronizacji &quot;zdalne&quot; instancje graczy otrzymują losowe wartości wejściowe dla swoich <a href="Defining_Inputs.htm">zdefiniowanych wejść</a>, co stanowi prostą formę testowania. Można to wyłączyć, używając <span class="inline"><a href="Rollback_Functions/rollback_use_random_input.htm">rollback_use_random_input()</a></span>.</p>
  <p><video class="center" src="../../../assets/Images/Scripting_Reference/GML/Reference/Rollback/rollback_two_players_synctest.mp4" width="856" height="420" controls="" align="center"></video></p>
  <p class="video_subtitle">Drugi gracz otrzymuje losowe dane wejściowe podczas testu synchronizacji.</p>
  <p>Podczas testu synchronizacji można także przypisać tymczasowe wejścia pozorowane do odtwarzaczy zdalnych. Więcej informacji na ten temat można znaleźć w temacie <a data-xref="{text}" href="Defining_Inputs.htm#h1">Wejście</a> próbne.</p>
  <h2>Efektywne tworzenie trybu wieloosobowego</h2>
  <p>Musisz dopilnować, aby wszystkie klienty gry uruchamiały <strong>tę samą logikę</strong> po otrzymaniu tych samych danych <strong>wejściowych</strong>. Jeśli dana instancja została utworzona lub przeniesiona tylko dla jednego klienta, nie będzie to miało odzwierciedlenia na innych klientach.</p>
  <p>Ten problem zwykle nie występuje, jeśli zaprogramujesz grę w sposób pokazany w rozdziale <a data-xref="{title}" href="Creating_Multiplayer.htm">Tworzenie gry wieloosobowej</a>, gdzie cała logika gracza działa tak samo dla wszystkich instancji gracza, niezależnie od tego, czy dana instancja jest <a href="Rollback_Variables/player_local.htm">lokalna, czy nie.</a> Jeśli jednak zaimplementujesz warunek, który będzie wykonywał jakąś czynność tylko dla konkretnego gracza, a dla innych nie, spowoduje to zakłócenie stanu gry.</p>
  <p>Koncepcyjnie wszystko sprowadza się do wejścia. Gracz 0 <strong>naciska Spację</strong>, co powoduje <strong>utworzenie pocisku</strong>. <strong>Pocisk </strong> ten<strong>porusza się w górę</strong> i w końcu <strong>zderza się z przeciwnikiem</strong>. Wróg zostaje <strong>zniszczony </strong>i <strong>powstaje eksplozja</strong>.</p>
  <p>W takim przykładzie ta sama logika działa na wszystkich klientach: instancja gracza 0 otrzymuje polecenie naciśnięcia klawisza spacji i tworzy pocisk <strong>w grze każdego gra</strong>cza. Następnie wszyscy gracze widzą kolejne efekty, czyli zderzenie pocisku z przeciwnikiem i eksplozję.</p>
  <h2 id="h1">Definiowanie obiektu gracza</h2>
  <h3>Automatyczne tworzenie instancji gracza</h3>
  <p>Jak pokazano w rozdziale <a data-xref="{title}" href="Creating_Multiplayer.htm">Tworzenie gry wieloosobowej</a>, możesz zdefiniować stronę <span class="notranslate">object</span> za pomocą adresu <span class="inline"><a href="Rollback_Functions/rollback_define_player.htm">rollback_define_player()</a></span>, a system automatycznie utworzy jej instancje dla każdego połączonego gracza. Będzie też niszczył jego instancje dla graczy, którzy się rozłączą.</p>
  <p>Utworzone w ten sposób instancje graczy mają automatycznie przypisane identyfikatory w zmiennej <span class="inline"><a data-xref="{title}" href="Rollback_Variables/player_id.htm">player_id</a></span>. W każdej instancji gracza można po prostu wywołać polecenie <a href="Rollback_Functions/rollback_get_input.htm"><span class="inline">rollback_get_input()</span></a> bez żadnych argumentów, co spowoduje, że otrzymasz dane wejściowe dla danego gracza.</p>
  <p>Jest to standardowy sposób korzystania z systemu cofania, ale można również ręcznie zarządzać instancjami graczy i ich wejściami.</p>
  <h3>Ręczne tworzenie instancji gracza</h3>
  <p>Aby ręcznie zarządzać instancjami graczy, nie wywołuj <span class="inline"><a href="Rollback_Functions/rollback_define_player.htm">rollback_define_player()</a></span>. Spowoduje to uruchomienie gry bez utworzenia żadnych instancji graczy.</p>
  <p>Następnie utwórz ręcznie własne instancje graczy, najlepiej w zdarzeniu <a data-xref="{text}" href="Rollback_Events.htm#h">Rollback Start</a>, i nadaj im identyfikatory graczy w zmiennej niestandardowej. Aby uzyskać dane wejściowe dla gracza, wywołaj polecenie <a href="Rollback_Functions/rollback_get_input.htm"><span class="inline">rollback_get_input()</span></a> i jako argument podaj identyfikator gracza.</p>
  <p>W ten sposób można ręcznie zarządzać czasem i sposobem tworzenia instancji graczy, przypisywanymi im identyfikatorami oraz pobieraniem danych wejściowych dla konkretnego gracza.</p>
  <p>Należy pamiętać, że zmienna <span class="inline"><a href="Rollback_Variables/player_local.htm">player_local</a></span> jest również tracona w przypadku stosowania metody ręcznej.</p>
  <h2>Pojedynczy gracz</h2>
  <p>Systemu Rollback można użyć podczas tworzenia gry dla jednego gracza. Wystarczy podać <strong>1</strong> jako liczbę graczy podczas wywoływania <span class="inline"><a href="Rollback_Functions/rollback_create_game.htm">rollback_create_game()</a></span>.</p>
  <p>W ten sposób system nigdy nie połączy się z żadną witryną <span class="notranslate">servers</span>, a gra będzie się toczyć w trybie offline, z możliwością rozszerzenia do gry wieloosobowej online, kiedy tylko zechcesz.</p>
  <p>Podejdź do tego w ten sposób, jeśli tworzysz nowy projekt, który w przyszłości może wykorzystywać rozgrywkę wieloosobową, ponieważ trudniej będzie wprowadzić ją do gry, gdy jest już ukończona, bez użycia systemu Rollback.</p>
  <h2>Więcej informacji</h2>
  <p>Więcej informacji na temat systemu Rollback można znaleźć na następnych stronach:</p>
  <ul class="colour">
    <li><a data-xref="{title}" href="Defining_Inputs.htm">Definiowanie danych wejściowych</a></li>
    <li><a data-xref="{title}" href="Rollback_Constraints.htm">Ograniczenia cofania</a></li>
    <li><a data-xref="{title}" href="Rollback_Events.htm">Zdarzenia cofnięcia</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div>Powrót: <a data-xref="{title}" href="Rollback_Multiplayer.htm">Rollback Multiplayer</a></div>
        <div>Następnie: <a data-xref="{title}" href="Defining_Inputs.htm">Definiowanie danych wejściowych</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Wszystkie prawa zastrzeżone.</span></h5>
  </div>
</body>
</html>