<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Najlepsze praktyki podczas programowania</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains some best practices when programming using GameMaker Studio 2" />
  <meta name="rh-index-keywords" content="Best Practices When Programming" />
  <meta name="search-keywords" content="best practices" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Najlepsze praktyki podczas programowania</h1>
  <p>Na tej stronie omówimy kilka &quot;najlepszych praktyk&quot; podczas programowania gry, a jednocześnie wyjaśnimy nieco działanie strony <span class="notranslate">GameMaker Studio 2</span>. Zanim jednak przejdziemy dalej, warto zwrócić uwagę na dwie bardzo ważne kwestie:</p>
  <ul class="colour">
    <li>To jest <em>przewodnik</em>, a nie definitywna i w 100% doskonała metoda pisania gry! Wymienione tu rzeczy dotyczą raczej organizacji i mikrooptymalizacji i powinny zostać włączone do Twoich nawyków programistycznych, gdy poczujesz się komfortowo z <span class="notranslate">GML</span> i uznasz, że są one odpowiednie.</li>
    <li>Jeśli gra działa dobrze i jesteś zadowolony z jej obecnego stanu, <em>nie śpiesz się ze zmianą wszystkiego tylko po to, aby wycisnąć kilka dodatkowych FPS-ów</em>. Trzeba znaleźć równowagę między czytelnym, elastycznym i modularnym kodem a czasem i energią potrzebną do jego zmiany, a także ogólnym zyskiem końcowym. Zasadniczo, jeśli coś nie jest zepsute, nie naprawiaj tego i zachowaj to, czego się tutaj nauczyłeś, do następnego projektu.</li>
  </ul>
  <p>W związku z tym przejdźmy dalej i przyjrzyjmy się kilku ogólnym wskazówkom dotyczącym pisania dobrego kodu <span class="notranslate">GML</span>, które można zastosować w dowolnym momencie...</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Styl programowania</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Jeśli chodzi o pisanie kodu, każdy ma swój <em>styl</em>. Styl, w jakim programujesz, to sposób rozmieszczania nawiasów, wcięć w wierszach, deklarowania i nazywania zmiennych itp. i jest on niezbędny do tego, aby Twój kod był czytelny dla innych ludzi (oraz dla Ciebie samego, gdy będziesz musiał wrócić do tego projektu po pewnym czasie pracy nad czymś innym).</p>
    <p class="dropspot">Istnieje wiele <a href="http://en.wikipedia.org/wiki/Programming_style">stylów programowania</a> i niektórzy twierdzą, że ich własny jest najlepszy, ale prawda jest taka, że prawie każdy styl jest w porządku, o ile jest się <strong>konsekwentnym </strong>w jego stosowaniu oraz <em>jasne </em>i <em>oczywiste </em>jest, czym jest i co robi.</p>
    <p class="dropspot"><img>Na powyższym rysunku przedstawiono przykład deklaracji funkcji w witrynie <span class="notranslate">script</span>, aby zilustrować powyższe punkty. Widać, że użyto w nim komentarzy w stylu JSDoc, aby jasno wyjaśnić, co to wszystko robi, a styl kodowania jest spójny, z wcięciami 4 spacjami, podkreśleniami używanymi dla zmiennych lokalnych, logowanym wyjściem itd.</p>
    <p class="dropspot">Należy również pamiętać, że chociaż edytor <span class="notranslate">script</span> pozwala na zwijanie kodu w każdym z nawiasów otwierających/zamykających, można użyć znaczników <span class="inline">#region</span> i <span class="inline">#endregion</span>, aby oddzielić fragmenty kodu i znacznie zwiększyć czytelność, zwłaszcza gdy mamy do czynienia z większymi <span class="notranslate">scripts</span>, które zawierają wiele funkcji. Regiony można także komentować - patrz sekcja Edycja na tej stronie podręcznika):</p>
    <p class="dropspot"><img>Pisząc kod, należy pamiętać, że podczas kompilacji finalnej wersji gry <span class="notranslate">GameMaker Studio 2</span> usuwa komentarze, niepotrzebne przerwy między wierszami i białe przestrzenie, podstawia wartości stałe/makro/enum i ogólnie kompresuje kod w ramach tego procesu. Oznacza to, że możesz dodać tyle białych linii wokół swojego kodu, ile potrzebujesz, i nie musisz się martwić o to, by komentarze były krótkie lub używane oszczędnie.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Używanie zmiennych lokalnych</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Kontynuując powyższy punkt dotyczący stylu programowania, jedną z rzeczy, którą robi wielu początkujących, jest upychanie jak największej ilości kodu w jednym wierszu. Na przykład:</p>
    <p class="code">draw_sprite(sprite_index, image_index, x + lengthdir_x(100, point_direction(x, y, mouse_x, mouse_y)), y + lengthdir_y(100, point_direction(x, y, mouse_x, mouse_y)));</p>
    <p class="dropspot">Choć nie jest to całkowicie nieczytelne, to jednak jest nieefektywne (na przykład funkcja <span class="inline">point_direction()</span> jest wywoływana dwukrotnie) oraz nieporządne i niewygodne do oglądania. O wiele lepiej byłoby to wyrazić jako:</p>
    <p class="code">var p_dir = point_direction(x, y, mouse_x, mouse_y);<br />
      var local_x = x + lengthdir_x(100, p_dir);<br />
      var local_y = y + lengthdir_y(100, p_dir);<br />
      draw_sprite(sprite_index, image_index, local_x, local_y);</p>
    <p class="dropspot">Ilość pamięci i zasobów potrzebnych do utworzenia tych zmiennych lokalnych jest znikoma, a znacznie przewyższa ją natychmiastowa korzyść, jaką Ty (lub ktokolwiek inny czytający kod później) odniesie z jego przejrzystości. Tę samą ideę należy stosować również w funkcjach, gdzie należy nadawać zmiennym wejściowym sensowne nazwy, a także stosować przejrzyste formatowanie i zmienne lokalne tam, gdzie jest to wymagane, aby kod był jak najbardziej czytelny.</p>
    <p class="dropspot">Zmienne lokalne są szybko przetwarzane w grze, więc wykorzystaj je jak najlepiej, a jeśli jakieś wyrażenie pojawia się w bloku kodu lub na stronie <span class="notranslate">script</span> dwa lub więcej razy, pomyśl o stworzeniu dla niego zmiennej lokalnej. Podczas korzystania z celów <a class="glossterm" data-glossterm="YoYo Compiler (YYC)" href="#">kompilatora YoYo (YYC)</a>, jeśli odwołujesz się do zmiennych <span class="inline">global</span> lub zmiennych instancji wiele razy w funkcji lub bloku kodu, szczególnie korzystne jest przypisanie ich do zmiennej lokalnej na początku kodu, a następnie odwołanie się do tej zmiennej lokalnej, ponieważ zapewni to znacznie lepszą wydajność.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Tablice</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot"><a href="../GameMaker_Language/GML_Overview/Arrays.htm">Tablice</a> są szybkie w użyciu i wymagają mniej pamięci niż struktury danych, ale można je jeszcze bardziej zoptymalizować. Podczas tworzenia tablicy pamięć jest przydzielana na podstawie jej rozmiaru, dlatego należy najpierw zainicjować tablicę do jej maksymalnego rozmiaru, nawet jeśli nie planuje się jej zapełnienia do późniejszego czasu. Na przykład, jeśli wiadomo, że tablica ma pomieścić maksymalnie 100 wartości, należy od razu zainicjować ją na 100 miejsc, używając funkcji <a href="../GameMaker_Language/GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a> function:</p>
    <p class="code">array = array_create(100, 0);</p>
    <p class="dropspot">Dzięki temu pamięć jest alokowana w jednym &quot;kawałku&quot;, a wszystkie wartości tablicy są ustawione na domyślną wartość 0. Dzięki temu wszystko przebiega szybko, ponieważ w przeciwnym razie po każdym dodaniu nowej wartości do tablicy cała pamięć musi zostać ponownie przydzielona.</p>
    <p class="note"><span class="note">UWAGA</span> W przypadku celu HTML5 przypisywanie tablic w ten sposób nie ma zastosowania i tablice powinny być inicjowane od 0 dla tego celu! Można sobie z tym łatwo poradzić, sprawdzając na przykład zmienną os_browser:</p>
    <p class="code"><span style="padding-left:1px;">if (os_browser == browser_not_a_browser)<br />
        {<br />
            array_create(100, 0);<br />
        }<br />
        else<br />
        {<br />
            for (var i = 0; i &lt; 100; ++i;)<br />
            {<br />
                array[i] = 0;<br />
            }<br />
        }</span></p>
    <p class="dropspot">Pamięć związaną z tablicą można również zwolnić, ustawiając zmienną w niej użytą na 0. Zatem, aby wyczyścić tablicę w powyższym przykładzie, wystarczy użyć polecenia</p>
    <p class="code">array = 0;</p>
    <p class="dropspot">Należy również pamiętać, że tablice są <strong>przekazywane przez referencję</strong>, ale po wprowadzeniu zmiany kopiują całą tablicę (takie zachowanie nazywa się copy <strong>on write</strong>). Tak więc, jeśli przekazujesz tablicę do funkcji, przekazujesz <em>referencję </em>do oryginalnej tablicy, a wszelkie wartości odczytane z niej będą pochodziły z oryginalnego źródła. Jest to ładne i szybkie, ale jeśli trzeba zmodyfikować wartości tablicy, to sama tablica jest powielana w punkcie zapisu i wszelkie dokonane zmiany <strong>muszą zostać zwrócone z funkcji, gdyż w przeciwnym razie zostaną utracone</strong>. Jest to znacznie wolniejsze i zużywa więcej pamięci, dlatego należy uważać na sposób używania tablic w funkcjach.</p>
    <p class="dropspot">Można jednak uniknąć tego zachowania przy kopiowaniu przy zapisie, używając specjalnego narzędzia <a href="../GameMaker_Language/GML_Overview/Accessors.htm">dostępu</a> do tablicy <span class="inline">@</span>, ponieważ zapewnia ono bezpośredni dostęp do tablicy. Na przykład:</p>
    <p class="code">// Call a function, passing our array<br />
      my_function(my_array);</p>
    <p class="code">// The function looks like this:<br />
      <br />
      function my_function(_a)<br />
      {<br />
          // The array will be copied and the copy modified,<br />
          // requiring you to use &quot;return _a&quot;, later<br />
          _a[0] = 100;<br />
      <br />
          // This will modify the ORIGINAL array directly and<br />
          // does not require it to be returned<br />
          _a[@ 0] = 100;<br />
      }
    </p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">Struktury danych</a></p>
  <div class="droptext" data-targetname="drop-down3">
    <p class="dropspot">W <span class="notranslate">GameMaker Studio 2</span> <a href="../GameMaker_Language/GML_Reference/Data_Structures/Data_Structures.htm">struktury danych</a> zostały zoptymalizowane tak, aby były znacznie szybsze niż poprzednie wersje <span class="notranslate">GameMaker</span>. Nadal muszą one być czyszczone (niszczone), gdy nie są używane, aby zwolnić pamięć, i nadal mogą być wolniejsze niż np. tablice, ale łatwość użycia i dodatkowe funkcje do obsługi danych, które zawierają, często przewyższają minimalną różnicę w szybkości, więc nie bój się używać ich w swoich grach.</p>
    <p class="dropspot">Należy zauważyć, że spośród wszystkich struktur danych mapy DS są szczególnie szybkie, zarówno przy odczycie, jak i zapisie, co czyni je doskonałym rozwiązaniem dla wszystkich rodzajów zadań.</p>
    <p class="dropspot">Wcześniej wspomnieliśmy o <a href="../GameMaker_Language/GML_Overview/Accessors.htm">accessorach</a> dla tablic, ale są one również dostępne dla struktur danych, co może pomóc w uporządkowaniu kodu i ułatwić jego czytanie.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#">Kolizje</a></p>
  <div class="droptext" data-targetname="drop-down4">
    <p class="dropspot">Istnieje <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Collisions/Collisions.htm">wiele sposobów radzenia sobie z kolizjami</a> w <span class="notranslate">GameMaker Studio 2</span>, a większość z nich wiąże się z dodatkowym obciążeniem procesora. Funkcje <span class="inline">collision_</span> i <span class="inline">point_</span>, <span class="inline">place_</span> oraz <span class="inline">instance_</span> polegają na sprawdzaniu pól <a class="glossterm" data-glossterm="ramka ograniczająca" href="#">ograniczających</a> dla wszystkich instancji danego typu w obszarze <span class="notranslate">room</span> i chociaż w silniku wbudowano pewne optymalizacje, aby ograniczyć te sprawdzenia, kolizje nigdy nie są najbardziej wydajną rzeczą, z jaką można sobie poradzić. Jeśli zaczniesz używać precyzyjnych kolizji, wydajność również wyraźnie się pogorszy, ponieważ nie tylko będziesz sprawdzał granice pola, ale także będziesz sprawdzał poszczególne piksele, co jest bardzo powolne. Na blogu technicznym <span class="notranslate">YoYo Games</span> można znaleźć informacje na ten temat:</p>
    <ul class="dropspotlist">
      <li class="dropspot"><a href="https://www.yoyogames.com/blog/32/the-hazards-of-precise-collision-detection">Zagrożenia związane z precyzyjnym wykrywaniem kolizji</a></li>
    </ul>
    <p class="dropspot">Nie oznacza to, że nie należy korzystać z tych funkcji, ponieważ mogą one być bardzo przydatne. Należy jednak wiedzieć, których z nich używać i kiedy, ponieważ wszystkie działają nieco inaczej i mają różną szybkość działania. Zasadniczo funkcje <span class="inline">place_</span> są szybsze od funkcji <span class="inline">instance_</span>, które są szybsze od funkcji <span class="inline">collision_</span> i <span class="inline">point_</span>, dlatego należy przeczytać strony podręcznika poświęcone każdemu z tych typów funkcji i wybrać najbardziej odpowiednią dla danej sytuacji.</p>
    <p class="dropspot">Alternatywą może być stworzenie<strong> systemu kolizji opartego na kafelkach</strong>, który można utworzyć za pomocą <a href="../GameMaker_Language/GML_Reference/Asset_Management/Rooms/Tile_Map_Layers/Tile_Map_Layers.htm">funkcji tilemap</a> lub nawet niestandardowej tablicy 2D albo siatki DS. Będą one bardzo szybkie i pomogą zwiększyć szybkość gry. Jeśli jednak używasz nieregularnego terenu lub ścian oraz strony <span class="notranslate">objects</span>, które nie są wyrównane do siatki, takie rozwiązanie może nie być odpowiednie. Bardzo prosty samouczek dotyczący kolizji map z płytkami można znaleźć na poniższym łączu wideo</p>
    <ul class="dropspotlist">
      <li class="dropspot"><a href="https://youtu.be/UyKdQQ3UR_0">Zderzenia kafelków w programie GameMaker Studio 2</a></li>
    </ul>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down5" href="#">Zamiana tekstur i partie wierzchołków</a></p>
  <div class="droptext" data-targetname="drop-down5">
    <p class="dropspot">Jeśli pod adresem <span class="notranslate">switch</span> klikniesz na przycisk <a href="../GameMaker_Language/GML_Reference/Debugging/show_debug_overlay.htm"><strong>nakładka debugowania</strong></a>zobaczysz, że podczas testowania na górze ekranu znajdują się dwie liczby w nawiasach. Pierwsza z nich to liczba wykonywanych <strong>podmian tekstur </strong>, a druga to liczba <strong>partii wierzchołków</strong>. Na te liczby wpływa wiele czynników i nigdy nie uda Ci się ich zejść do poziomu (0) (0), ponieważ silnik wymaga wykonania jednego lub dwóch z każdego kroku, ale powinieneś dążyć do tego, aby te wartości były jak najniższe.</p>
    <p class="dropspot"><img>W przypadku zamiany <span class="notranslate">texture</span> najlepszym i najbardziej efektywnym sposobem jest zoptymalizowanie sposobu, w jaki <span class="notranslate">sprites</span> i tła są przechowywane na stronie <span class="notranslate">texture</span>. Można to zrobić we <a href="../The_Asset_Editors/Sprites.htm">właściwościach sprite</a>'a, a strony <span class="notranslate">texture</span> można tworzyć w <a href="../Settings/Texture_Groups.htm">Edytorze grup tekstur</a>. Jeśli masz kilka obrazów, które są używane tylko w menu głównym (na przykład), umieść je na osobnej <a href="../Settings/Texture_Information/Texture_Pages.htm">stronie tekstur</a>. To samo dotyczy obrazów charakterystycznych dla danego poziomu, gracza i przeciwników itp. Zasadniczo chcesz je pogrupować według zastosowań, aby ograniczyć do minimum podmianę tekstur. Dodatkowo, aby zoptymalizować pamięć <a class="glossterm" data-glossterm="VRAM" href="#">VRAM</a>, możesz użyć różnych funkcji <a href="../GameMaker_Language/GML_Reference/Drawing/Textures/Textures.htm">prefetch i flush</a>, aby załadować i usunąć z pamięci stronę <span class="notranslate">textures</span> w zależności od potrzeb.</p>
    <p class="note"><span class="note">UWAGA</span> Jak wspomniano na początku tej strony, jeśli Twoja gra działa dobrze i z przyzwoitym FPS, nie przejmuj się zbytnio podmianą adresu <span class="notranslate">texture</span>... zwłaszcza podczas tworzenia projektów na komputerach stacjonarnych. Te optymalizacje najlepiej sprawdzają się w przypadku dużych gier lub na urządzeniach przenośnych o niskiej wydajności, a niewłaściwie zastosowane mogą negatywnie wpływać na wydajność.</p>
    <p class="dropspot">Informacje o wierzchołkach są wysyłane w &quot;partiach&quot; do układu GPU podczas rysowania i generalnie im większa partia, tym lepiej. Dlatego podczas rysowania należy unikać &quot;przerywania&quot; partii, ponieważ zwiększy to liczbę partii wierzchołków wysyłanych do układu GPU. Istnieje wiele rzeczy, które przerywają partię, a główne z nich to <strong>tryby mieszania</strong>, zmiana <strong>shadera</strong>, zmiana uniformu na <span class="notranslate">shader</span> przed rysowaniem czegoś oraz rysowanie przy użyciu wbudowanych kształtów i prymitywów.</p>
    <p class="dropspot">Na przykład, jeśli masz wiele instancji pocisków, które rysują w trybie mieszania <span class="inline">bm_add</span>, dla każdej z nich będziesz tworzyć nowy adres <span class="notranslate">vertex batch</span>, co jest zdecydowanie złą rzeczą! Zamiast tego utwórz w swojej grze kontroler <span class="notranslate">object</span>, który będzie rysował wszystkie kule, na przykład tak:</p>
    <p class="code">gpu_set_blendmode(bm_add);<br />
      <br />
      with (obj_BULLET)<br />
      {<br />
          draw_self();<br />
      }<br />
      <br />
      gpu_set_blendmode(bm_normal);
    </p>
    <p class="note"><span class="note">UWAGA</span> Nie dotyczy to tylko <span class="inline" style="font-size: 14px">bm_add</span> - każda zmiana mieszania spowoduje przerwanie partii i będzie miała wpływ na wydajność.</p>
    <p class="dropspot">W ten sposób wszystkie kule zostaną narysowane w tej samej partii. Rozsądne korzystanie z funkcji <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendenable.htm"><span class="inline">gpu_set_blendenable()</span></a>, <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestref.htm"><span class="inline">gpu_set_alphatestref()</span></a>, oraz <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestenable.htm"><span class="inline">gpu_set_alphatestenable()</span></a> można włączać i wyłączać w zależności od potrzeb w całym kodzie projektu, chociaż mogą one nie być odpowiednie dla wszystkich typów grafiki lub projektów.</p>
    <p class="note"><span class="note">UWAGA</span> Jeśli nie potrzebujesz, aby instancja rysowała się sama, gdy używasz kontrolera w ten sposób, możesz po prostu dodać komentarz do zdarzenia Draw, aby wyłączyć domyślne rysowanie, lub uczynić instancję niewidoczną (uniemożliwi to jednak uruchamianie kodu dla instancji we wszystkich zdarzeniach draw).</p>
    <p class="dropspot">Innym sposobem na zmniejszenie tych liczb jest wyłączenie opcji <strong>Oddzielna strona <span class="notranslate">Texture</span> </strong> dla strony <span class="notranslate">sprites</span>, o ile nie jest to absolutnie konieczne. Każdy obraz zapisany w ten sposób jest wysyłany na własną stronę <span class="notranslate">texture</span> i inaczej pakowany, więc lepiej jest mieć te obrazy na zwykłej stronie <span class="notranslate">texture</span>. Następnie można uzyskać współrzędne UVS za pomocą funkcji <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a> i przechowywać je w zmiennych do późniejszego wykorzystania. Może to być niewielka ilość dodatkowego kodu, ale korzyści, jakie uzyskasz, są tego warte. Należy pamiętać, że ta metoda nie pozwala na powtórzenia <span class="notranslate">texture</span>!</p>
    <p class="dropspot">Podobnie jak w przypadku wszystkich innych porad, jeśli zmiana tego utrudnia ci życie, a gra działa dobrze, nie przejmuj się tym zbytnio...</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down6" href="#">Cząstki stałe</a></p>
  <div class="droptext" data-targetname="drop-down6">
    <p class="dropspot"><a href="../GameMaker_Language/GML_Reference/Drawing/Particles/Particles.htm">Cząsteczki</a> to bardzo szybki i wydajny sposób tworzenia dynamicznych efektów w grze, który generalnie zapewnia dobrą wydajność. Warto jednak zauważyć, że używanie mieszania addytywnego, mieszania alfa i mieszania kolorów na cząsteczkach może obniżyć tę wydajność, zwłaszcza na urządzeniach przenośnych, więc jeśli nie potrzebujesz tych funkcji, nie używaj ich! Zwłaszcza mieszanie addytywne może znacznie zwiększyć liczbę werteksów, dlatego należy z niego korzystać ostrożnie.</p>
    <p class="dropspot">Należy pamiętać, że w przypadku przeglądarki HTML5 nie korzystającej z technologii WebGL posiadanie wielokolorowych, zanikających cząstek będzie wymagało buforowania wielu obrazów i będzie bardzo powolne. Ponieważ jednak cząsteczki <span class="notranslate">sprites</span> mogą być animowane, można utworzyć animowany obraz <span class="notranslate">sprite</span>, który ma podobrazy zmieniające kolor, a następnie użyć go jako cząsteczki. Nadal będzie to wyglądać jak stopniowa zmiana koloru, ale nie będzie wymagać ciągłego tworzenia obrazów <span class="notranslate">cache</span>.</p>
    <p class="dropspot">Więcej informacji o cząsteczkach można znaleźć na stronie <a href="Guide_To_Using_Particles.htm">Przewodnik po używaniu cząst</a>eczek.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down7" href="#">Powierzchnie</a></p>
  <div class="droptext" data-targetname="drop-down7">
    <p class="dropspot">Na koniec zajmiemy się krótko używaniem <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/Surfaces.htm">powierzchni</a>, ponieważ <span class="notranslate">GameMaker Studio 2</span> ma dość istotną optymalizację, jeśli chodzi o używanie ich w grach: możliwość <span class="notranslate">switch</span> włączania i wyłączania <strong>bufora głębokości</strong>.</p>
    <p class="dropspot">Jeśli używasz powierzchni w normalny sposób, GMS2 utworzy powierzchnię i towarzyszącą jej głębię <span class="notranslate">buffer</span>, aby zapewnić prawidłowe sortowanie głębokości podczas rysowania czegokolwiek w 3D. Jednak w większości gier 2D ta dodatkowa głębia <span class="notranslate">buffer</span> nie jest potrzebna i zajmuje dodatkowe miejsce w pamięci oraz czas przetwarzania, który można by wykorzystać do innych celów. W tym miejscu funkcja <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_depth_disable.htm"><span class="inline">surface_depth_disable()</span></a> wchodzi do gry...</p>
    <p class="dropspot">Funkcję tę można wywołać przed utworzeniem powierzchni, aby wyłączyć generowanie głębi <span class="notranslate">buffer</span>, a wszystkie utworzone później powierzchnie nie będą miały utworzonej głębi <span class="notranslate">buffer</span>. Funkcję tę można włączać i wyłączać w zależności od potrzeb, a nawet można ją wywołać raz na początku gry, aby wyłączyć generowanie głębi <span class="notranslate">buffers</span> dla wszystkich kolejnych wywołań powierzchni (w większości gier 2D jest to w porządku). Nie spowoduje to znacznego wzrostu wydajności, ale warto o tym pamiętać, jeśli gra w dużym stopniu opiera się na powierzchniach, i może zapobiec wyczerpaniu pamięci na urządzeniach o niższej specyfikacji.</p>
  </div>
  <p> </p>
  <p>Poza wymienionymi powyżej najważniejszymi kwestiami istnieją inne, bardziej ogólne rzeczy, które mogą pomóc w zwiększeniu wydajności i które również są uważane za &quot;dobre praktyki&quot;:</p>
  <ul class="colour">
    <li>nie bój się używać funkcji trygonometrycznych, ponieważ (wbrew powszechnej opinii) są one dość szybkie, zwłaszcza w porównaniu z cząstkami, zderzeniami, <span class="notranslate">strings</span>, itd.</li>
    <li>nie umieszczaj w zdarzeniach Draw kodu, który nie służy do rysowania przedmiotów</li>
    <li>używać alarmu do wywoływania dowolnego kodu, który nie musi być wywoływany co krok (zamiast dodawać go do zdarzenia Step)</li>
  </ul>
  <p>Jednak, jak już wspomnieliśmy na początku strony, wszystkie te optymalizacje są opcjonalne i jeśli Twoja gra działa dobrze przy 60 partiach wierzchołków, 80 <span class="notranslate">texture</span> podmianach, mieszaniu addytywnym itp. to nie przejmuj się tym zbytnio! Po prostu pamiętaj o tych rzeczach, programując swoją następną grę...</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Powrót: <a href="Additional_Information.htm">Informacje dodatkowe</a></div>
        <div style="float:right">Następny: <a href="The_File_System.htm">System plików</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Wszystkie prawa zastrzeżone.</span></h5>
  </div>
  <!-- KEYWORDS
Nest Practices
-->
  <!-- TAGS
best_practices
-->
</body>
</html>