<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Właściwości pomieszczenia</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing the different room properties" />
  <meta name="rh-index-keywords" content="Rooms - Room Settings" />
  <meta name="search-keywords" content="room settings,cameras,viewports,room size,room properties,view cameras" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Właściwości pomieszczenia</h1>
  <p><img>W sekcji Właściwości witryny <span class="notranslate">Room</span> można ustawić przełącznik dziedziczenia ustawień, zmienić opcje, takie jak trwałość, rozmiar pomieszczenia oraz zarządzać rzutniami.</p>
  <h2>Trwały</h2>
  <p>Zwykle po opuszczeniu strony <span class="notranslate">room</span> i powrocie do tej samej strony <span class="notranslate">room</span> w późniejszym czasie, ustawienia strony <span class="notranslate">room</span> zostają zresetowane do ustawień początkowych. W większości gier jest to w porządku, ale może nie odpowiadać oczekiwaniom użytkowników, np. w grach RPG lub innych grach nieliniowych, w których użytkownik chce przechodzić między stronami <span class="notranslate">rooms</span> i mieć je w stanie, w jakim opuścił je ostatnim razem. Zaznaczenie pola wyboru oznaczonego jako <strong>Persistent (Trwały </strong>) spowoduje właśnie to. Stan <span class="notranslate">room</span> zostanie zapamiętany i gdy wrócisz do niego później, będzie dokładnie taki sam, jak przy ostatnim wejściu, a stan początkowy zostanie przywrócony dopiero po ponownym uruchomieniu gry. Istnieje <em>jeden </em>wyjątek - jeśli zaznaczysz, że niektóre <span class="notranslate">objects</span> są trwałe, instancje tego <span class="notranslate">object</span> <em>nie </em>pozostaną w <span class="notranslate">room</span>, lecz zostaną przeniesione do następnego <span class="notranslate">room</span>.</p>
  <h2 id="clear_display_buffer">Wyczyść bufor wyświetlacza</h2>
  <p>Następnie można wybrać opcję <strong>Wyczyść bufor wyświetlania</strong>. Ta opcja, jeśli jest zaznaczona, powoduje wstępne wypełnienie <a class="glossterm" data-glossterm="bufor wyświetlacza" href="#">bufora wyświetlania</a> kolorem przed narysowaniem czegokolwiek innego w danej klatce. Jeśli wiesz, że twoje widoki będą zajmować cały ekran przez cały czas lub że rysowane jest pełnoekranowe, nieprzezroczyste tło, możesz odznaczyć tę opcję, co zaoszczędzi ponownego rysowania, a tym samym pomoże zoptymalizować grę.</p>
  <p>Jeśli jednak masz wiele widoków, które po wyświetleniu na ekranie pozostawiają wolne miejsca, lub tło ma przezroczyste elementy, możesz zaznaczyć tę opcję, aby wszystkie puste obszary były wypełniane wybranym kolorem rysowania. Obecnie kolor ten można ustawić tylko za pomocą kodu przy użyciu <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/The_Game_Window/window_set_colour.htm"><span class="inline">window_set_colour()</span></a>.</p>
  <p class="note"><span class="note">UWAGA</span> Jeśli korzystasz z automatycznej korekcji proporcji obrazu (ustawionej w <a href="../../Settings/Game_Options.htm">Opcjach gry</a>), powinna ona być <strong>zawsze </strong>zaznaczona, w przeciwnym razie mogą wystąpić dziwne efekty w &quot;letterboxie&quot;, w którym rysowana jest gra. Jeśli nie korzystasz z tej opcji, możesz ją odznaczyć i uzyskać niewielki wzrost wydajności gry (szczególnie widoczny na <span class="notranslate">Android</span> i innych platformach mobilnych).</p>
  <h2>Szerokość, wysokość i inne opcje</h2>
  <p>Strona <span class="notranslate">room</span> musi mieć swój rozmiar, który jest określany przez wartości szerokości i wysokości w pikselach, które są wprowadzane przez użytkownika.</p>
  <p>Następnie można dodać <strong>kod tworzenia</strong>, jeśli jest on potrzebny. Kod tworzenia dodaje się za pomocą przycisku na dole (wraz z przełącznikiem <span class="notranslate">inherit</span>, który mówi, czy <span class="notranslate">room</span> ma <span class="notranslate">inherit</span> swój kod tworzenia, czy nie), a po kliknięciu go otworzy się edytor kodu lub edytor wizualny. W edytorze tym można wprowadzać funkcje/działania i kod, które będą uruchamiane na <em>początku </em> <span class="notranslate">room</span>, po zdarzeniu create wszystkich instancji, ale przed ich zdarzeniem startowym <span class="notranslate">room</span> (więcej informacji o kolejności zdarzeń znajdziesz <a href="../Object_Properties/Event_Order.htm">tutaj</a>). Ten kod będzie uruchamiany za każdym razem, gdy wejdziesz na stronę <span class="notranslate">room</span>, chyba że <span class="notranslate">room</span> jest oznaczony jako trwały, w takim przypadku będzie uruchamiany tylko raz, gdy <span class="notranslate">room</span> zostanie po raz pierwszy wprowadzony, ale nie przy kolejnych wizytach na stronie <span class="notranslate">room</span>.</p>
  <h2 id="creation_order">Kolejność tworzenia instancji</h2>
  <p>Ostatni przycisk w oknie Właściwości <span class="notranslate">Room</span> umożliwia otwarcie okna <strong>Kolejność tworzenia instancji:</strong> </p>
  <p><img>To okno zawiera listę wszystkich instancji w witrynie <span class="notranslate">room</span> w kolejności, w jakiej zostaną utworzone (od góry do dołu). Jeśli chcesz, by konkretna instancja została utworzona przed innymi, możesz po prostu kliknąć na stronie <img> i przeciągnąć ją na żądaną pozycję. Zauważ, że instancje będą tworzone w kolejności od góry do dołu listy.</p>
  <div data-conref="../../assets/snippets/Instance_creation_order_warning.hts"> </div>
  <p> </p>
  <p> </p>
  <h1>Kamery i wizjery</h1>
  <p>Kolejnym zestawem właściwości strony <span class="notranslate">room</span>, które można zdefiniować, są właściwości związane z <strong>kamerą</strong> pomieszczenia i <strong>rzutniami</strong>. Widok z kamery umożliwia rysowanie różnych części strony <span class="notranslate">room</span> w różnych miejscach ekranu lub rysowanie tylko części strony <span class="notranslate">room</span> tak, aby obejmowała cały ekran. Na przykład w większości gier platformowych widok z kamery podąża za głównym bohaterem, ponieważ gdybyś mógł zobaczyć cały poziom na ekranie, Twoja postać byłaby zbyt mała, aby ją dostrzec, a gracz nie miałby żadnych niespodzianek. Widoki z kamery mogą być także wykorzystywane w grach wieloosobowych lub kooperacyjnych, ponieważ pozwalają na stworzenie konfiguracji z podziałem ekranu, w której w jednej części ekranu widać jednego gracza, a w innej drugiego. Wszystko to można łatwo osiągnąć w programie <span data-keyref="GameMaker Name">GameMaker</span> za pomocą widoków z kamery.</p>
  <p><img>W górnej części właściwości widoku można włączyć lub wyłączyć dziedziczenie widoków, a następnie znajduje się pole oznaczone jako <strong>Włącz</strong> rzutnie. To pole <em>musi być zaznaczone</em>, aby w grze można było używać widoków z kamery.</p>
  <p class="note"><span class="note">UWAGA</span> Można włączyć lub wyłączyć dziedziczenie dla trzech głównych ustawień rzutni, a następnie można włączyć lub wyłączyć dziedziczenie dla każdego indywidualnego widoku z kamery.</p>
  <p>Kolejne pole wyboru to <strong>Clear Viewport Background (Wyczyść tło</strong> rzutni), które jest podobne do opcji <a href="#clear_display_buffer">Clear Display Buffer (Wyczyść bufor wyświetlania</a> ) opisanej powyżej, ale dotyczy rzutni. Gdy opcja ta jest włączona, przed narysowaniem każdej klatki <a class="glossterm" data-glossterm="powierzchnia zastosowania" href="#">powierzchnia aplikacji</a> jest oczyszczana z koloru okna. Gwarantuje to, że przez przezroczyste obszary tła, takie jak zawartość poprzednich klatek, nie będą widoczne żadne niezamierzone elementy graficzne; dlatego ważne jest, aby włączyć tę opcję (wraz z opcją &quot;<strong>Włącz rzutnie</strong>&quot;), jeśli tło zawiera przezroczystość.</p>
  <p>Widok z kamery jest definiowany przez dwa różne zestawy wartości: sam widok z kamery oraz port na ekranie, w którym ten widok ma być rysowany. Może to czasem powodować nieporozumienia, więc wyjaśnijmy to nieco, zanim wyjaśnimy, jak definiujemy każdą z tych wartości:</p>
  <ul class="colour">
    <li><strong>Kamera</strong>: Punkt w witrynie <span class="notranslate">room</span>, który będzie używany do określania sposobu wyświetlania witryny <span class="notranslate">room</span> na ekranie (jest to abstrakcyjny punkt w edytorze <span class="notranslate">room</span>, a jego pozycja jest ustawiana automatycznie na podstawie ustawień widoku i portu widoku).</li>
    <li><strong>Widok:</strong> To, co widzi kamera, w oparciu o jej położenie, rzut i obrót</li>
    <li><strong>Port podglądu</strong>: obszar ekranu fizycznego, na którym będzie wyświetlany obraz z kamery</li>
  </ul>
  <p><img>Oznacza to na przykład, że można mieć widok z kamery o rozdzielczości 640x480 na stronie <span class="notranslate">room</span>, a następnie ustawić port na 320x240, co spowoduje wyświetlenie na ekranie widoku przeskalowanego do tego rozmiaru portu, można też zrobić to samo i ustawić widok na mniejszą wartość, a port na większą, dzięki czemu obraz zostanie przeskalowany do rozmiaru portu i wyświetlony na ekranie w większym rozmiarze niż jest. W ten sposób można zachować rozmiar ekranu (portu), zmieniając jednocześnie widok z kamery, aby wyświetlić więcej lub mniej obrazu z witryny <span class="notranslate">room</span> w tym samym obszarze ekranu.</p>
  <p>Widok z kamery jest zawsze definiowany jako prostokątny obszar w witrynie <span class="notranslate">room</span>, gdzie określa się położenie lewego górnego rogu, szerokość i wysokość tego obszaru. Następnie należy określić, gdzie ten obszar jest wyświetlany w oknie na ekranie, definiując port widoku, w którym ponownie określa się położenie lewego górnego rogu oraz rozmiar (należy pamiętać, że wszelkie wartości inne niż 0,0 dla lewego górnego rogu mogą dać dziwne rezultaty). Można mieć więcej niż jeden port i mogą one zachodzić na siebie - w takim przypadku są rysowane we wskazanej kolejności, jeden na drugim.</p>
  <p>Należy pamiętać, że całkowity obszar ekranu jest <em>zawsze definiowany jako prostokąt</em>, więc porty, nawet jeśli są przesunięte, będą tworzyć prostokąt, a wszelkie puste miejsca będą wypełniane kolorem okna <a class="glossterm" data-glossterm="bufor wyświetlacza" href="#">bufora</a> <strong>wyświetlacza</strong>. Ilustruje to poniższy obrazek, na którym widoczne są dwa odsunięte porty widoku, ale tworzą one kwadratowe okno, a &quot;pod spodem&quot; znajdują się linie rysowane do bufora wyświetlacza:</p>
  <p><img>Kamery mają także opcję <strong>Śledzenie obiektu </strong>. Jest ona przydatna, gdy chcesz, aby kamera &quot;podążała&quot; (tzn. utrzymywała widok zogniskowany na określonym obiekcie) <span class="notranslate">object</span>. Aby to zrobić, musisz kliknąć <img> na ikonie menu i wybrać <span class="notranslate">object</span> z wyświetlonej listy (jeśli na stronie <span class="notranslate">object</span> znajduje się wiele instancji tego adresu <span class="notranslate">room</span>, kamera będzie śledzić tylko jedną z nich).</p>
  <p>Normalnym zachowaniem kamery jest poruszanie się tylko wtedy, gdy śledzona postać zbytnio zbliży się do strefy &quot;buforowej&quot;, która stanowi niewidzialną granicę wokół krawędzi widoku. Tę strefę można zdefiniować za pomocą wartości <strong>Horizontal Border </strong>i <strong>Vertical Border </strong>, więc na przykład ustawienie tych wartości na 64 będzie oznaczać, że widok nie zacznie się poruszać i śledzić postaci, dopóki nie znajdzie się ona w odległości 64 pikseli od krawędzi widoku.</p>
  <p>Na koniec możesz określić <strong>poziomą</strong> i <strong>pionową prędkość </strong>, z jaką porusza się kamera, gdy postać znajdzie się w strefie <span class="notranslate">buffer</span>. Domyślna wartość to -1. Ta domyślna wartość jest w zasadzie &quot;natychmiastowa&quot; i oznacza, że w momencie, gdy instancja podążająca za postacią znajdzie się poza poziomą lub pionową granicą strefy <span class="notranslate">buffer</span>, widok przeskoczy do bieżącej pozycji. Nie zawsze jest to pożądane, dlatego można ustawić szybkość przewijania kamery w pionie i poziomie, ustawiając wartości inne niż -1. Pamiętaj, że wartość 0 spowoduje, że widok nie będzie się w ogóle poruszał, a każda inna dodatnia wartość określa, o ile pikseli przesunie się w danej klatce, więc ustawienie prędkości poziomej na 5 spowoduje, że widok będzie podążał za stroną <span class="notranslate">object</span> w poziomie z prędkością 5 pikseli na klatkę.</p>
  <p> </p>
  <p> </p>
  <h1>Fizyka pomieszczenia</h1>
  <p>Zanim będziesz mógł korzystać z wbudowanych funkcji fizyki w swoich grach, musisz poinformować <span data-keyref="GameMaker Name">program GameMaker</span>, że strona <span class="notranslate">room</span> jest stroną fizyki <span class="notranslate">room</span>. Aby to zrobić, musisz zaznaczyć opcję <strong>Włącz </strong>fizykę u góry sekcji Fizyka <em>pomieszczenia</em> (możesz też przełączać dziedziczenie tej sekcji niezależnie od pozostałych ustawień <span class="notranslate">room</span> ). Po wykonaniu tych czynności można przejść do ustawienia właściwości świata fizyki, czyli kilku podstawowych właściwości, które muszą być wstępnie zdefiniowane, zanim <span class="notranslate">room</span> pozwoli na działanie instancji fizyki jako takich. Aby uzyskać bardziej precyzyjną kontrolę nad światem, można użyć kodu (więcej informacji na ten temat można znaleźć w rozdziale <a href="../../GameMaker_Language/GML_Reference/Physics/Physics.htm">Funkcje fizyki</a> ).</p>
  <p><img>Następną rzeczą, którą należy zrobić, jest ustawienie <strong>grawitacji </strong>świata. Jej siła i kierunek są obliczane jako <a class="glossterm" data-glossterm="wektor" href="#">wektor</a> pozycji x/y, którą ustawiasz wokół punktu (0, 0). Zatem x równe 0, a y równe 1 spowoduje, że kierunek grawitacji będzie skierowany w <em>dół </em>z siłą 1 metra na sekundę (bardziej szczegółowe informacje na ten temat można znaleźć w podręczniku <a href="../../GameMaker_Language/GML_Reference/Physics/The_Physics_World/The_Physics_World.htm">Świat fizyki</a>).</p>
  <p>Na koniec musisz ustawić stosunek liczby<strong> pikseli do metrów</strong>, aby <span data-keyref="GameMaker Name">program GameMaker</span> używał go jako podstawy do wszystkich obliczeń fizyki. Jest tak dlatego, że funkcje fizyki działają na podstawie rzeczywistych pomiarów, dlatego też musimy ustawić tę wartość. Będziesz chciał dostosować to ustawienie do momentu, gdy średni rozmiar pikseli używanej strony <span class="notranslate">objects</span> przełoży się w przybliżeniu na symulację fizyki <span class="notranslate">objects</span> o odpowiednim rozmiarze.</p>
  <p>Należy zauważyć, że włączenie fizyki w witrynie <span class="notranslate">room</span> oznacza, że wszystkie instancje w pomieszczeniu <em>muszą korzystać z funkcji i zmiennych fizyki, aby się poruszać</em>. Zasadniczo istnieje ruch &quot;tradycyjny&quot;, w którym można ustawić pozycję X/Y instancji lub ustawić jej prędkość i kierunek, oraz ruch &quot;fizyczny&quot;, który wymaga sił fizycznych i impulsów do poruszania się. Te systemy <strong>wzajemnie się wykluczają</strong> i nie można poruszać instancją fizyki za pomocą funkcji niefizycznych, a także nie można poruszać instancją niefizyczną za pomocą funkcji fizycznych.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Powrót: <a href="../Rooms.htm">Redaktor <span class="notranslate">Room</span> </a></div>
        <div style="float:right">Następny: <a href="Room_Inheritance.htm">Dziedziczenie pomieszczeń</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Wszystkie prawa zastrzeżone.</span></h5>
  </div>
  <!-- KEYWORDS
Room Properties
View Ports
View Cameras
-->
  <!-- TAGS
rooms_properties
-->
</body>
</html>