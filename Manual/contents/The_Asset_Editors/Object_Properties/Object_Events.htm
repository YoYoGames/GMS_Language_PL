<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Wydarzenia dotyczące obiektów</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing the events system and the different events in an object" />
  <meta name="rh-index-keywords" content="Objects - Events" />
  <meta name="search-keywords" content="events,object events,events list" />
  <link rel="stylesheet" type="text/css" href="../../assets/css/default.css" />
  <script src="../../assets/scripts/main_script.js"></script>
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Wydarzenia dotyczące obiektów</h1>
  <p>Czym więc są <strong>wydarzenia</strong> <span class="notranslate">object</span>? Zasadniczo są to dyskretne momenty w grze <span class="notranslate">loop</span>, w których rzeczy dzieją się zgodnie z tym, co dla nich zaprogramowałeś. <span class="notranslate">GameMaker Studio 2</span> działa w cyklach takich zdarzeń - od momentu rozpoczęcia <span class="notranslate">room</span> do momentu zakończenia gry <span class="notranslate">loop</span> działa gra, w której co <strong>krok </strong>uruchamiana lub sprawdzana jest seria zdarzeń, a ty możesz umieścić w swojej <span class="notranslate">objects</span> kod lub akcje DnD™, które reagują na te zdarzenia (krok jest momentem w czasie gry, regulowanym przez ustawienie prędkości <span class="notranslate">room</span>, i może być również nazywany <strong>ramką</strong>).</p>
  <p>Przyjrzyjmy się typowej konfiguracji strony <span class="notranslate">object</span> z uwzględnieniem zdarzeń i kodu:</p>
  <p><img>Jak widać na naszym przykładzie <span class="notranslate">object</span>, na liście znajduje się wiele zdarzeń, na które powinna ona reagować, ale początkowo, gdy tworzysz stronę <span class="notranslate">object</span>, lista ta jest pusta i musisz zdecydować, które zdarzenia są potrzebne i co instancje tej strony <span class="notranslate">object</span> powinny zrobić, gdy te zdarzenia zostaną wywołane. Aby dodać zdarzenia do <span class="notranslate">object</span>, należy nacisnąć przycisk <em>Dodaj</em> zdarzenie znajdujący się na dole listy zdarzeń, co spowoduje wyświetlenie następującego okna:</p>
  <p><img>Jest to lista wszystkich podstawowych zdarzeń i kategorii zdarzeń, na które może reagować <span class="notranslate">object</span>, a w ramach każdej kategorii znajdują się zdarzenia podrzędne, które umożliwiają dalsze doprecyzowanie zachowań. Na przykład, jeśli klikniesz kategorię zdarzeń<strong>Naciśnięcie</strong> <strong>klawisza</strong> <img>, pojawi się kolejne okno ze zdarzeniami, które pozwalają wybrać, na <em>jaki </em>klawisz ma reagować <span class="notranslate">object</span>. Po wybraniu zdarzenia zostanie do niego dołączone okno kodu (lub okno DnD™ <span class="notranslate">workspace</span> ) i otworzy się ono po prawej stronie. Możesz teraz edytować kod, aby nadać swojej witrynie <span class="notranslate">object</span> określone zachowanie lub reakcję na dane zdarzenie.</p>
  <p>Można kliknąć prawym przyciskiem myszy <img> na dowolnym zdarzeniu, które zostało dodane do strony <span class="notranslate">object</span>, aby uzyskać następujące opcje menu:</p>
  <p><img>Są to następujące opcje:</p>
  <ul class="colour">
    <li><strong>Dodaj</strong> wydarzenie - dodawanie nowego wydarzenia z listy wydarzeń.</li>
    <li>Wytnij<strong>/ </strong> <strong>Kopiuj / </strong> <strong>Wklej</strong> zdarzenia - Wytnij, skopiuj lub wklej wybrane zdarzenie. Można też użyć standardowych skrótów klawiaturowych: <img> / <img> + <span class="inline">X</span>, <img> / <img> + <span class="inline">C</span>, oraz <img> / <img> + <span class="inline">V</span>.</li>
    <li><strong>Duplikuj</strong> zdarzenie - powiela wybrane zdarzenie. Spowoduje to pobranie zawartości wybranego zdarzenia i powielenie jej w innym, określonym przez użytkownika zdarzeniu.</li>
    <li><strong>Zmień</strong> wydarzenie - zmiana wydarzenia. Zostanie wyświetlony monit o wybranie innej kategorii zdarzenia, a po jej wybraniu zawartość bieżącego zdarzenia zostanie zmieniona na nowe zdarzenie (przy jednoczesnym usunięciu pierwotnego zdarzenia).</li>
    <li><strong>Convert To <span class="notranslate">Drag and Drop</span> / Code (Konwertuj na / Kod</strong> ) - zdarzenia na stronie <span class="notranslate">Object</span> będą tworzone przy użyciu metody wybranej podczas tworzenia projektu, czyli przy użyciu kodu lub akcji Drag and Drop™. Dzięki tej opcji można konwertować z jednej na drugą, niezależnie od typu projektu.</li>
    <li><strong>Usuń</strong> zdarzenie - usuwa zdarzenie (lub zdarzenia).</li>
  </ul>
  <p>Podczas usuwania zdarzeń można użyć <img> + <img>, aby zaznaczyć wiele zdarzeń, a następnie usunąć je wszystkie razem. Każda utworzona strona <span class="notranslate">object</span> ma własną listę zdarzeń, które są do niej dodawane z <strong>Edytora obiektów</strong>. Zdarzenia te dzielą się na dwie kategorie:</p>
  <ul class="colour">
    <li>te, które uruchamiają każdy krok gry</li>
    <li>te, które są &quot;wyzwalane&quot; przez zdarzenie w grze, takie jak osiągnięcie przez instancję krawędzi <span class="notranslate">room</span> lub naciśnięcie klawiatury albo myszy.</li>
  </ul>
  <p>Pełna lista wydarzeń znajduje się poniżej:</p>
  <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down8" href="#">Utwórz stronę</a></p>
  <div class="droptext" data-targetname="drop-down8">
    <p class="dropspot">To zdarzenie ma miejsce, gdy po raz pierwszy tworzona jest instancja <span class="notranslate">object</span>, i jest pierwszą rzeczą, która dzieje się w instancji umieszczonej w <span class="notranslate">room</span> za pośrednictwem edytora <span class="notranslate">Room</span>, gdy zostanie wprowadzona <span class="notranslate">room</span>. Oznacza to, że to zdarzenie jest idealnym miejscem do inicjalizacji <a class="glossterm" data-glossterm="zmienna" href="#">zmiennych</a>, uruchamiania <a href="../Timelines.htm">linii czasowych</a>, ustawiania <a href="../Paths.htm">ścieżek</a> itp. oraz wykonywania wszelkich innych czynności, które zazwyczaj muszą być wykonane tylko raz lub tylko podczas pierwszego tworzenia instancji w <span class="notranslate">room</span>. Jeśli na stronie <span class="notranslate">object</span> dodano zmienne <strong>obiektu</strong> lub <strong>zmienne</strong> instancji w Edytorze <span class="notranslate">Object</span> lub Edytorze <span class="notranslate">Room</span>, zmienne te zostaną najpierw zainicjowane, a następnie zostanie uruchomione zdarzenie <strong>Create Event</strong>.</p>
    <p class="dropspot">Pamiętaj, że wszystko, co zostało ustawione w zdarzeniu tworzenia, możesz modyfikować w <a href="../Room_Properties/Layer_Properties.htm">kodzie</a> tworzenia instancji w edytorze <span class="notranslate">Room</span>, ponieważ jest on uruchamiany bezpośrednio po zdarzeniu tworzenia instancji i może być użyty do tworzenia <strong>zmiennych</strong> instancji lub zastępowania zmiennych dodanych jako zmienne <span class="notranslate">Object</span> lub w samym zdarzeniu tworzenia.</p>
    <div data-conref="../../assets/snippets/Instance_creation_order_warning.hts"> </div>
    <p class="dropspot"> </p>
  </div>
  <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down9" href="#">Zniszcz</a></p>
  <div class="droptext" data-targetname="drop-down9">
    <p class="dropspot">To zdarzenie jest zdarzeniem, które zostanie wykonane, gdy instancja zostanie zniszczona. Często jest ono pomijane przy dodawaniu zachowań do <span class="notranslate">objects</span>, ale może być bardzo użyteczne, na przykład przy tworzeniu efektów eksplozji lub cząsteczek po zabiciu wroga, lub przy ponownym uruchomieniu nowej instancji w innej części , a nawet przy dodawaniu punktów do wyniku.
      nową instancję <span class="notranslate">object</span> w innej części <span class="notranslate">room</span>, a nawet do dodawania punktów do wyniku.</p>
    <p class="dropspot"> </p>
  </div>
  <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#">Sprzątanie</a></p>
  <div class="droptext" data-targetname="drop-down10">
    <p class="dropspot"><span>To zdarzenie zostanie wywołane po każdym zdarzeniu, które spowoduje usunięcie instancji <span class="notranslate">object</span> z witryny <span class="notranslate">room</span>. Zostanie więc wywołane, jeśli:</span></p>
    <ul class="dropspotlist">
      <li class="dropspot"><span>instancja zostanie zniszczona</span></li>
      <li class="dropspot"><span> <span class="notranslate">room</span> kończy się</span></li>
      <li class="dropspot"><span>gra się kończy</span></li>
    </ul>
    <p class="dropspot"><span>Służy do &quot;czyszczenia&quot; wszelkich zasobów dynamicznych w grze (takich jak powierzchnie, struktury danych itp.) lub do wykonywania zadań, które mają być wykonane <em>jednorazowo </em>, gdy instancja zostanie w jakikolwiek sposób usunięta z gry.</span></p>
    <p class="dropspot"><span>Zauważ, że to zdarzenie zostanie wywołane <em>natychmiast </em>po zdarzeniu, które je wywołało, ale instancja nie zostanie faktycznie usunięta z gry <strong>aż do zakończenia bieżącego</strong> zdarzenia. Na przykład, jeśli wywołasz <span class="inline">instance_destroy()</span> w zdarzeniu Step, zostanie wywołane zdarzenie Destroy, następnie zdarzenie Clean Up, a po nim <em>zakończy się reszta zdarzenia Step</em> Event. Oznacza to, że każdy kod, który zostanie wykonany po wywołaniu <span class="inline">instance_destroy()</span>, będzie nadal wykonywany i może być przyczyną błędów, jeśli wyczyszczono strukturę danych lub inny zasób wymagany przez ten kod, dlatego należy zachować ostrożność podczas korzystania z tego zdarzenia.</span>
    </p>
    <p> </p>
  </div>
  <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down11" href="#">Alarm</a></p>
  <div class="droptext" data-targetname="drop-down11">
    <p class="dropspot">Kategoria alarmów jest podzielona na 12 zdarzeń, po jednym dla każdego z możliwych alarmów, które można ustawić w danej instancji. Tak więc po kliknięciu kategorii <em>Dodaj </em>alarm pojawi się to okno:</p>
    <p class="dropspot"><img>W tym miejscu należy wybrać alarm, który ma zostać utworzony, a po wykonaniu tej czynności zostanie on dodany do okna zdarzeń
      dzięki czemu można do niego dodawać kod w normalny sposób. Ale co to jest alarm? Otóż jest to specjalne zdarzenie, które nie robi nic, chyba że alarm został wcześniej ustawiony, a następnie czeka, aż alarm odliczy do 0, zanim wykona czynności
      lub kodu, który został do niego dodany.</p>
    <p class="dropspot">Po osiągnięciu przez alarm wartości 0 i uruchomieniu kodu będzie on odliczał do -1, gdzie pozostanie aż do ponownego ustawienia (co oznacza, że można sprawdzić, czy wartość alarmu jest większa niż -1, co pozwoli określić, czy alarm działa, czy nie). Tak więc, powiedzmy
      że w zdarzeniu create <span class="notranslate">object</span> ustawisz wartość <span class="inline">alarm[0]</span> na 30, oznacza to, że <span class="notranslate">GameMaker Studio 2</span> będzie odliczać 30 kroków gry, zanim wykona akcje lub kod umieszczony w zdarzeniu <span class="inline">alarm[0]</span>. Zauważ, że ustawienie alarmu na 0 <em>nie </em>spowoduje uruchomienia kodu alarmu, ponieważ zdarzenie zostanie wywołane, ale alarm zostanie natychmiast ustawiony na -1, więc kod zostanie pominięty. Jeśli alarm ma być uruchamiany w następnym kroku, należy ustawić go na 1.</p>
    <p class="dropspot">Może to być bardzo przydatne, ponieważ pozwala na uruchamianie elementów w ściśle określonych momentach, a nawet ich powtarzanie, ponieważ nic nie stoi na przeszkodzie, aby ustawić alarm w osobnym zdarzeniu. Wyobraź sobie, że masz potwora i chcesz, aby obracał się w prawo co
      co trzy sekundy... ustawiasz alarm w zdarzeniu tworzenia na prędkość <span class="notranslate">room</span> * 3 (jeśli prędkość <span class="notranslate">room</span> wynosi 30, to jest to 30 kroków na sekundę, więc pomnóż to przez 3 i otrzymasz 3 sekundy!
      aby ustawić jego kierunek, a także akcję (lub kod), aby ustawić alarm na prędkość <span class="notranslate">room</span> * 3 ponownie. W ten sposób można skonfigurować prostą grę <span class="notranslate">loops</span>, w której pewne rzeczy dzieją się tylko w określonych odstępach czasu.</p>
    <p class="dropspot">Warto zauważyć, że alarm, w którym nie ma żadnych akcji ani kodu, <em>nie </em>będzie odliczał czasu. Jednak nawet w przypadku samego komentarza, bez kodu lub akcji, alarm będzie nadal odliczał czas i można go ustawiać i sprawdzać w normalny sposób.</p>
    <p class="dropspot"> </p>
  </div>
  <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down12" href="#">Krok</a></p>
  <div class="droptext" data-targetname="drop-down12">
    <p class="dropspot">GameMaker Studio 2 dzieli czas na <strong>kroki </strong>, a prędkość <span class="notranslate">room</span> określa, ile tych kroków ma być na sekundę (krok można też nazwać <strong>klatką</strong>). Pojedynczy krok to w zasadzie strona <span class="notranslate">loop</span>, która działa
      więc, jak można sobie wyobrazić, zdarzenie <strong>Step </strong>jest zdarzeniem, które jest sprawdzane w każdym kroku gry, gdy istnieje jej instancja.</p>
    <p class="dropspot">Etap ten składa się z trzech etapów, które opisano poniżej:</p>
    <p class="dropspot"><img>Do większości zadań wystarczy standardowe zdarzenie kroku, ale czasami chcemy mieć większą kontrolę nad tym, jaki kod ma być uruchamiany i w jakim czasie.
      i w jakim czasie. W tym celu udostępniono zdarzenia <strong>Begin </strong>i <strong>End </strong>step. Wszystkie trzy są sprawdzane w każdym kroku, ale ich kolejność nie zmieni się nawet wtedy, gdy przyszłe aktualizacje silnika <span class="notranslate">GameMaker Studio 2</span> zmienią inne zdarzenia.
      Oznacza to, że jest to jedyna niezawodna metoda upewnienia się, że coś zawsze dzieje się przed czymś innym.</p>
    <p class="dropspot">Do czego można wykorzystać zdarzenie step? Cóż, można je wykorzystać do działań lub kodu, który musi być wykonywany w sposób ciągły. Na przykład, jeśli jedna strona <span class="notranslate">object</span> ma podążać za drugą, można tutaj dostosować kierunek ruchu do strony <span class="notranslate">object</span>, za którą podążamy
      aby zachować płynność ruchu za nim. Należy jednak uważać z tym zdarzeniem i nie umieszczać wielu skomplikowanych akcji w zdarzeniu step w <span class="notranslate">objects</span>, zwłaszcza jeśli planujesz mieć wiele instancji <span class="notranslate">object</span> w swojej grze <span class="notranslate">room</span>, ponieważ może to
      spowolnić grę. Wiele rzeczy można umieszczać w alarmach lub ustawiać ich wyzwalanie za pomocą <strong>innych </strong>zdarzeń, zamiast wykonywać je przez cały czas.</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#">Kolizja</a></p>
  <div class="droptext" data-targetname="drop-down13">
    <p class="dropspot">Oczywiście podczas tworzenia gry bardzo ważne jest, aby wiedzieć, kiedy dwie (lub więcej) instancje obiektu <span class="notranslate">object</span> zderzą się ze sobą, dlatego mamy zdarzenie <strong>kolizji</strong>. Jest to zdarzenie, które umieszcza się w witrynie <span class="notranslate">object</span>, a następnie określa się
      z którym innym <span class="notranslate">object</span> należy sprawdzić, czy nie doszło do kolizji.</p>
    <p class="dropspot">Jeśli fizyka nie jest włączona, kolizje te będą obliczane na podstawie maski obu stron <span class="notranslate">objects</span> (maska jest określana we właściwościach <span class="notranslate">sprite</span> lub może być przypisana niezależnie we właściwościach <span class="notranslate">object</span> ) oraz na podstawie tego, czy się pokrywają
      czy też nie. Zauważ, że jeśli jedna lub druga instancja w kolizji nie ma przypisanej maski (lub maska <span class="notranslate">sprite</span> jest ustawiona na zero), to <em>nawet jeśli coś rysuje</em>, nie zostaną wykryte żadne kolizje.</p>
    <p class="dropspot">Jeśli masz włączoną <strong>fizykę </strong>, kolizja będzie oparta na typie <strong>kształtu kol</strong> izji<em>(Fixture</em>), który zdefiniowałeś dla <span class="notranslate">object</span> w jego właściwościach fizyki, podobnie jak jego reakcja na kolizję. To
      Oznacza to, że do obsługi kolizji może nie być potrzebny żaden kod, ale zdarzenie będzie musiało <em>zawierać przynajmniej komentarz </em>, aby kolizje zostały wykryte.</p>
    <p class="dropspot">Na koniec należy zauważyć, że wszystkie kolizje będą obliczane raz na krok gry przed wywołaniem zdarzenia kolizji, tak więc gdy zdarzenie kolizji zostanie uruchomione, wszystkie kolizje zostaną już obliczone i wstępnie przypisane. Oznacza to, że
      jeśli utworzysz instancję w tym zdarzeniu, a następnie spróbujesz sprawdzić, czy doszło do kolizji, kolizja nie zostanie wykryta ani rozwiązana aż do następnej <a class="glossterm" data-glossterm="iteracja" href="#">iteracji</a> gry <span class="notranslate">loop</span>.</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">Klawiatura,</a>  <img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">Prasa do klawiatury,</a>  <img> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">Odblokowanie klawiatury</a></p>
  <div class="droptext" data-targetname="drop-down14">
    <p class="dropspot">Umożliwienie graczowi sterowania różnymi aspektami gry jest bardzo ważne. W tym celu na stronie <span class="notranslate">GameMaker Studio 2</span> udostępniono bardzo obszerną listę zdarzeń klawiaturowych, które można wykorzystać w każdej z trzech głównych kategorii klawiatur. W przypadku
      w kategorii Klawiatura ogólna, jest ono wyzwalane w sposób ciągły co krok, tak długo, jak długo wciśnięty jest wybrany klawisz, podczas gdy zdarzenia w kategorii Naciśnięcie i zwolnienie są wyzwalane tylko raz, gdy klawisz jest początkowo wciśnięty lub zwolniony.</p>
    <p class="dropspot">Należy zauważyć, że zdarzenia klawiatury są wywoływane we wszystkich aktywnych instancjach w witrynie <span class="notranslate">room</span> za każdym razem, gdy zostanie użyty klawisz, ale zareagują tylko te, które mają zdefiniowane zdarzenie dla danego klawisza.
     <span class="notranslate">object</span> Można utworzyć wiele zdarzeń klawiaturowych w dowolnej witrynie <span class="notranslate">object</span>, a instancje tej witryny zareagują na nie wszystkie podczas gry.</p>
    <p class="dropspot">Po dodaniu dowolnego zdarzenia klawiaturowego do witryny <span class="notranslate">object</span> zostanie wyświetlone menu zdarzeń podrzędnych klawiatury, w którym można określić klawisz, który ma być sprawdzany:</p>
    <p class="dropspot"><img>Większość z nich jest dość oczywista, ale omówmy pokrótce poszczególne sekcje - na samej górze znajdują się klawisze strzałek,
      następnie najczęściej używane klawisze modyfikatorów, potem reszta klawiatury (podzielona na dalsze podsekcje, aby można było uzyskać dokładną informację o wymaganym klawiszu, np. <img> lub <img>), a na końcu dwa bardzo specjalne podzdarzenia, <strong>Brak</strong> klawisza i <strong>Dowolny</strong> klawisz. Jak sugerują ich nazwy, są to zdarzenia podrzędne
      które sprawdzają, czy nie został naciśnięty <em>żaden </em>klawisz lub czy został naciśnięty <em>dowolny </em>klawisz. Należy pamiętać, że klawisze klawiatury numerycznej wywołują odpowiednie zdarzenia tylko wtedy, gdy włączona jest funkcja <strong>Number Lock </strong>.</p>
    <p class="dropspot">Zdarzenia <strong>Naciśnięcie </strong>i <strong>Zwolnienie </strong>klawiatury są niemal dokładnie takie same jak zwykłe zdarzenia klawiatury, z tą różnicą, że zamiast wyzwalać je w sposób ciągły, są one wyzwalane tylko raz. Gdy klawiatura po raz pierwszy zarejestruje
      że klawisz został naciśnięty, wygeneruje zdarzenie <strong>Naciśnięcie</strong> klawisza (oraz zwykłe zdarzenie Klawiatura), a za pierwszym razem, gdy klawisz nie będzie już wykrywany jako naciśnięty, wygeneruje pojedyncze zdarzenie <strong>Zwolnienie</strong> klawisza.</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#">Mysz</a></p>
  <div class="droptext" data-targetname="drop-down16">
    <p class="dropspot">Kategoria Mysz jest podzielona na serię zdarzeń, które można wybrać, aby uzyskać bardziej precyzyjną kontrolę nad tym, co dzieje się w grze. Tutaj można zobaczyć, jakie dokładnie są to zdarzenia:</p>
    <p class="dropspot"><img>Wszystkie zdarzenia związane z lewym <img>, prawym <img> i środkowym <img> przyciskiem ( <strong>normalne</strong>, <strong>wciśnięte </strong>lub <strong>zwolnione</strong>)
      działają na maskę instancji, której dotyczy zdarzenie. Oznacza to, że <span class="notranslate">GameMaker Studio 2</span> sprawdzi położenie myszy na stronie <span class="notranslate">room</span>, gdy zostaną użyte te przyciski, względem masek kolizji instancji, w których wystąpiło zdarzenie myszy. Jeśli
      dojdzie do &quot;kolizji&quot; z polem <a class="glossterm" data-glossterm="ramka ograniczająca" href="#">ograniczającym</a> instancji, zostanie wywołane zdarzenie, więc upewnij się, że każda instancja z tymi zdarzeniami ma stronę <span class="notranslate">sprite</span> z poprawną maską kolizji lub że strona ma poprawną maskę kolizji.
      lub że na stronie <span class="notranslate">object</span> we właściwościach <span class="notranslate">sprite</span> jest wybrana maska <span class="notranslate">object</span>. Jak sugerują ich nazwy, zdarzenia te będą wywoływane albo jednorazowo, gdy wybrany przycisk myszy zostanie po raz pierwszy naciśnięty lub zwolniony, albo w sposób ciągły w każdym kroku, gdy przycisk jest
      utrzymywane.
    </p>
    <p class="dropspot">Zdarzenia wejścia i wyjścia myszy są również podobne do zdarzeń przycisków w tym sensie, że ich działanie również zależy od maski instancji, ale tym razem są one wyzwalane, gdy mysz po raz pierwszy &quot;wejdzie&quot; (dotknie) instancji lub gdy &quot;opuści&quot; (przestanie dotykać) instancję.
      (przestaje dotykać) instancję. Zdarzenia te nie są jednak ciągłe i są wyzwalane tylko raz za każdym razem, gdy mysz wejdzie lub opuści instancję <span class="notranslate">object</span> - są więc idealną metodą do tworzenia np. przycisków, które mają się zmieniać, gdy mysz
      a następnie wracają do normalnego stanu po usunięciu myszy.</p>
    <p class="dropspot">Na koniec mamy jeszcze jedną sekcję zdarzeń myszy, która nosi nazwę Mysz <strong>globalna</strong>. W tym podmenu znajduje się wybór zdarzeń, które służą do rejestrowania zdarzeń myszy w instancjach, nawet jeśli mysz nie znajduje się nad nimi lub
      w ich pobliżu. Są to zdarzenia, które są generowane dla <em>wszystkich </em>instancji i jeśli dla danego zdarzenia zdefiniowane są akcje lub kod, to zostaną one wykonane, niezależnie od położenia myszy w grze <span class="notranslate">room</span>.</p>
    <p class="dropspot">Należy pamiętać, że w urządzeniach przenośnych lub z ekranem dotykowym lewy przycisk myszy <img> może być również używany do sprawdzania zakładki palca na ekranie dotykowym, a prawy przycisk myszy <img> jest wyzwalany przez podwójne stuknięcie w ekran (to zachowanie można zmienić za pomocą kodu).</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down18" href="#">Gesty</a></p>
  <div class="droptext" data-targetname="drop-down18">
    <p class="dropspot">Jest to zdarzenie, które zostanie wywołane przez użytkownika dotykającego ekranu (na urządzeniach mobilnych) lub klikającego i poruszającego myszą (na wszystkich innych platformach). Zdarzenia te są podobne do zdarzeń myszy, ponieważ istnieją wersje zwykłe oraz wersje <em>globalne</em>.
      Zwykłe wersje tych zdarzeń są wyzwalane tylko wtedy, gdy dotknięcie nastąpi na instancji, która ma stronę <span class="notranslate">sprite</span> (lub maskę), a dotknięcie nastąpi w jej <a class="glossterm" data-glossterm="ramka ograniczająca" href="#">polu ograniczającym</a>. Wersje globalne
      będą wyzwalane przez dotknięcie przez użytkownika <em>dowolnego miejsca </em>na ekranie.</p>
    <p class="dropspot">Zdarzenia związane z gestami pozwalają wykryć następujące elementy:</p>
    <ul class="dropspotlist">
      <li class="dropspot"><img> <strong>stuknięcia - </strong> gdy użytkownik klika/dotyka i szybko zwalnia przycisk</li>
      <li class="dropspot"><img> <strong>przeciąganie - </strong> gdy użytkownik dotknie/kliknie i przytrzyma, a następnie przesunie palec/kursor</li>
      <li class="dropspot"><img> kliknięcia <strong>- </strong> gdy użytkownik przesuwa i zwalnia dotyk/kliknięcie jednym ruchem</li>
      <li class="dropspot"><img> <strong>uszczypnięcia - </strong> gdy użytkownik trzyma dwa palce na ekranie, a następnie przesuwa je razem/oddziela od siebie</li>
      <li class="dropspot"><img> <strong>obraca - </strong> gdy użytkownik trzyma dwa palce na ekranie, a następnie obraca je wokół punktu</li>
    </ul>
    <p class="dropspot"><img>Różne zdarzenia będą zawsze zawierały mapę DS o nazwie &quot;<span class="inline">event_data</span>&quot;, która
      zawiera szereg par klucz/wartość z danymi dotyczącymi pozycji i ruchu dotknięcia/kliknięcia. Szczegółowe informacje o wszystkich dostępnych zdarzeniach podrzędnych i sposobie ich działania można znaleźć w następującej sekcji:</p>
    <ul class="dropspotlist">
      <li class="dropspot"><a href="Gesture_Events.htm">Wydarzenie "Gest</a></li>
    </ul>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down19" href="#">Inne</a></p>
  <div class="droptext" data-targetname="drop-down19">
    <p class="dropspot">Istnieje wiele specjalnych zdarzeń, które można wykorzystać podczas tworzenia gier w witrynie <span class="notranslate">GameMaker Studio 2</span>. Są one w większości zgrupowane pod nazwą Inne zdarzenie i można je wybrać z menu podręcznego, które pojawia się po wybraniu tej opcji. Poniżej znajduje się
      obraz wszystkich tych innych zdarzeń:</p>
    <p class="dropspot"><img>Więcej informacji na temat każdego z wydarzeń przedstawionych na powyższej ilustracji można znaleźć w następującej części:</p>
    <ul class="dropspotlist">
      <li class="dropspot"><a href="Other_Events.htm">Pozostałe wydarzenia</a></li>
    </ul>
    <p class="dropspot"> </p>
  </div>
  <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down20" href="#">Rysuj</a></p>
  <div class="droptext" data-targetname="drop-down20">
    <p class="dropspot">Ta kategoria zdarzeń decyduje o tym, co widać na ekranie po uruchomieniu gry, i jest podzielona na różne zdarzenia:</p>
    <p class="dropspot"><img>Jak widać, kategoria zdarzeń rysowania zawiera wiele różnych typów zdarzeń. Zdarzenia Draw <strong>Begin</strong>, <strong>Draw </strong>i <strong>Draw End</strong> są &quot;standardowymi&quot; zdarzeniami rysowania, z których prawdopodobnie będziesz korzystać najczęściej. Domyślnie główne zdarzenie Draw jest wywoływane zawsze dla każdej instancji, niezależnie od tego, czy ma ona adres <span class="notranslate">sprite</span>, czy nie, choć jeśli <span class="notranslate">flag</span> instancja jest niewidoczna, zdarzenie
      nie zostanie wywołane (należy o tym pamiętać, jeśli w zdarzeniu draw niewidocznej instancji <span class="notranslate">object</span> znajduje się jakaś logika gry, ponieważ nie zostanie ona uruchomiona). Zdarzenie main draw jest także miejscem, w którym <span class="notranslate">GameMaker Studio 2</span> domyślnie rysuje instancję <span class="notranslate">sprite</span>, jeśli w zdarzeniu nie ma żadnego kodu ani
      akcji w tym zdarzeniu (tzn. nie dodano go do listy zdarzeń dla <span class="notranslate">object</span>). Domyślne rysowanie wykorzystuje instancję <span class="notranslate">sprite</span> powiązaną z instancją i będzie ją rysować z wszelkimi przekształceniami ustawionymi w kodzie lub zastosowanymi akcjami.</p>
    <p class="dropspot">Standardowe zdarzenia rysowania rysują <em>przed </em>zdarzeniami Rysuj <strong>GUI </strong>oraz <em>pomiędzy </em>zdarzeniami <strong>Pre </strong>Draw i <strong>Post Draw </strong>, co oznacza, że wszystko, co zostanie narysowane w tym zdarzeniu, zostanie narysowane pod tym
      w zdarzeniu Rysuj interfejs <strong>graficzny </strong>, niezależnie od warstwy (tzn. wszystko, co zostało narysowane w zdarzeniu Rysuj interfejs graficzny, będzie zawsze rysowane nad wszystkim, co zostało narysowane w zwykłym zdarzeniu rysowania, niezależnie od kolejności warstw).</p>
    <p class="dropspot">Powyżej przedstawiono ogólny zarys działania zdarzeń losowania, ale szczegółowe informacje na temat wszystkich dostępnych zdarzeń podrzędnych można znaleźć w następującej sekcji:</p>
    <ul class="dropspotlist">
      <li class="dropspot"><a href="Draw_Events.htm">Wydarzenie losowania</a></li>
    </ul>
    <p> </p>
    <p> </p>
    <p class="dropspot"> </p>
  </div>
  <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down21" href="#">Asynchroniczne</a></p>
  <div class="droptext" data-targetname="drop-down21">
    <p class="dropspot">Ta kategoria zdarzeń jest szczególna, ponieważ zdarzenia w niej zawarte nie są domyślnie wyzwalane przez stronę <span class="notranslate">GameMaker Studio 2</span>, ale raczej przez zakończenie jakiejś innej akcji, na przykład załadowanie pliku lub odpowiedź z witryny <span class="notranslate">server</span>. Kategoria ta jest podzielona na
      następujące zdarzenia:</p>
    <p class="dropspot"><img alt="Object Editor Events View" class="center" src="../../assets/Images/Asset_Editors/Editor_Objects_Events.png" /></p>
    <p class="dropspot">Załóżmy, że chcesz dodać plik graficzny do strony <span class="notranslate">GameMaker Studio 2</span>. Cóż, zakodowałbyś to w innym zdarzeniu (być może w zdarzeniu Create) strony <span class="notranslate">object</span>, a następnie kazałbyś stronie <span class="notranslate">object</span> narysować pasek ładowania podczas oczekiwania (na przykład), wywołując odpowiednie zdarzenie asynchroniczne
      aż do <a class="glossterm" data-glossterm="callback" href="#">wywołania zwrotnego</a>, które poinformuje <span class="notranslate">GameMaker Studio 2</span>, że plik został załadowany. Dane zwrócone w tym zdarzeniu można następnie wykorzystać do innych czynności, np. zmiany adresu <span class="notranslate">room</span> lub zakupu przedmiotu.</p>
    <p class="dropspot">Powyżej przedstawiono ogólny zarys działania zdarzenia asynchronicznego, natomiast szczegółowe informacje na temat wszystkich dostępnych zdarzeń podrzędnych można znaleźć w następnej sekcji:</p>
    <ul class="dropspotlist">
      <li class="dropspot"><a href="Async_Events.htm">Lista zdarzeń asynchronicznych</a></li>
    </ul>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>Należy również pamiętać, że zdarzenia można nazywać, a przynajmniej nadawać im krótki tekst opisowy, który będzie wyświetlany obok nich w Edytorze zdarzeń. Aby to zrobić, wystarczy w pierwszej linii edytora kodu zdarzenia dodać następujący tekst:</p>
  <p class="code">/// @description Your text here</p>
  <p>Na przykład w zdarzeniu <strong>alarmowym </strong>można zapisać coś takiego</p>
  <p class="code">/// @description This is the AI Fight alarm</p>
  <p>Teraz w Edytorze zdarzeń zobaczysz to:</p>
  <p><img alt="Object Editor Events List" class="center" src="../../assets/Images/Asset_Editors/Editor_Objects_EventList.png" /></p>
  <p>W przypadku użytkowników DnD™ dodanie komentarza wymaga użycia akcji <strong>Wykonaj kod</strong>, którą należy umieścić na samej górze listy akcji dla danego zdarzenia, przed wszystkimi innymi. Po dodaniu tej akcji należy nadać jej tę samą linijkę kodu, która została pokazana powyżej, aby nazwać zdarzenie, np:</p>
  <p><img>Dodatkowe informacje na temat niektórych z powyższych imprez oraz ogólny porządek przebiegu imprez można znaleźć w poniższych sekcjach:</p>
  <ul class="colour">
    <li><a href="Event_Order.htm">Kolejność zdarzeń</a></li>
    <li><a href="Other_Events.htm">Pozostałe wydarzenia</a></li>
    <li><a href="Draw_Events.htm">Wydarzenia związane z losowaniem</a></li>
    <li><a href="Async_Events.htm">Zdarzenia asynchroniczne</a></li>
    <li><a href="Gesture_Events.htm">Wydarzenia związane z gestami</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Powrót: <a href="../Objects.htm">Redaktor <span class="notranslate">Object</span> </a></div>
        <div style="float:right">Następny: Obiekty macierzyste</div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Wszystkie prawa zastrzeżone.</span></h5>
  </div>
  <!-- KEYWORDS
Object Events
Named Events
-->
  <!-- TAGS
object_events
-->
</body>
</html>