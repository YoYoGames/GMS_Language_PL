
    Przewodnik po użyciu cząstek
    Ten przewodnik jest dla tych z Was, którzy chcą zrozumieć, jak używać i tworzyć cząsteczki. Na tej stronie omówione zostaną zarówno funkcje języka GameMaker, jak i akcje wizualne GML dla cząsteczek. Jeśli nigdy wcześniej nie używałeś cząsteczek, mamy nadzieję, że ten przewodnik pomoże ci zacząć, ponieważ są one bardzo przydatne i całkiem zabawne w tworzeniu.
    Zanim przejdziemy dalej, powinniśmy wyjaśnić, czym właściwie jest cząstka... Zasadniczo cząstka to zasób graficzny, który ma pewne właściwości zdefiniowane przez system cząstek. Właściwościami tymi nie można manipulować bezpośrednio w przypadku pojedynczych cząstek, ale są one zmieniane zbiorczo za pomocą kodu lub akcji, które są używane do zdefiniowania systemu, do którego cząstka należy. Są one bardzo przydatne do tworzenia w grze pięknych i krzykliwych efektów lub subtelnych i dyskretnych efektów bez narzutu na procesor, jaki powoduje używanie instancji.
    Wspomnieliśmy już o systemach cząsteczek, więc zanim przejdziemy dalej, wyjaśnijmy, co to jest. Pomyśl o systemie cząsteczek jak o pojemniku, w którym przechowujesz cząsteczki gotowe do użycia. Możesz użyć kodu lub akcji, aby zdefiniować wizualny aspekt cząsteczek, a następnie umieścić je w "pojemniku" (systemie cząsteczek), abyś mógł je wyjąć i użyć w dowolnym miejscu i czasie.
    Przed skonfigurowaniem systemu i stworzeniem cząsteczek warto wiedzieć kilka rzeczy... Po pierwsze, większość kodu systemu cząsteczek jest wywoływana tylko raz w grze, zwykle w jakimś kontrolerze object na pierwszym room lub poziomie - nie zawsze tak jest, ale dla uproszczenia w dalszej części poradnika użyjemy tego scenariusza, ponieważ jest to najczęstszy sposób używania cząsteczek. Robisz to, ponieważ system cząsteczek, raz utworzony, pozostaje w pamięci i jest gotowy do użycia w każdej chwili, więc jeśli utworzysz go więcej niż raz, może to szybko zwiększyć wykorzystanie pamięci i spowodować poważne opóźnienia, a nawet może spowodować awarię gry. Dla uproszczenia w tym poradniku utworzysz globalny system cząsteczek, który będzie mógł być używany przez dowolną instancję w grze w dowolnym momencie.
     
    Tworzenie układu cząstek
    
      Na początek należy zdefiniować system cząsteczek i nadać mu nazwę, aby można było z niego korzystać. Ponieważ ma to być system globalny, z którego będzie mógł korzystać każdy object, należy to zrobić w kontrolerze object lub w funkcji inicjalizacyjnej uruchamianej na początku gry. Strona GML wygląda następująco:
      global.P_System = part_system_create_layer("Instance_Layer", false);
      I przy użyciu strony GML Visual:
      Należy pamiętać, że podana nazwa warstwy musi być poprawną warstwą w witrynie room, w której system będzie używany, w przeciwnym razie nie będą widoczne żadne cząsteczki. Zauważ też, że ustawiliśmy wartość "persistent" flag (zarówno w kodzie, jak i na stronie GML Visual) na false. Trwały system cząsteczek to taki, który "przetrwa" w różnych miejscach rooms bez potrzeby niszczenia i ponownego tworzenia go dla każdej strony room. Aby jednak zachować prostotę, w tym poradniku nie będziemy używać trwałości.
      Tak oto powstał system, ale co z cząstkami? Je też musimy zdefiniować, bo inaczej system jest bezużyteczny i nic nie robi.
       
    
    Definiowanie typu cząstki
    
      Aby użyć cząstki w systemie, trzeba najpierw zdefiniować jej ogólne właściwości. Są one podobne do właściwości object, ale odnoszą się tylko w sposób ogólny do poszczególnych cząstek. Oznacza to, że jeśli nadasz cząsteczkom minimalną prędkość ruchu równą 1 i maksymalną 2, to każda cząsteczka utworzona przez system będzie miała losową prędkość między 1 a 2 piksele na krok, a ogólnie rzecz biorąc, jej średnia prędkość wyniesie 1,5. Powinieneś nazwać i dodać do systemu swoją pierwszą cząstkę, korzystając z poniższego adresu GML w tym samym object, którego użyłeś do utworzenia systemu:
      global.Particle1 = part_type_create();
      A dla tych z Was, którzy używają strony GML Visual:
      Zauważ, że korzystając z witryny GML Visual, zaznaczamy także opcję mieszania . Umożliwia to mieszanie addytywne dla cząstek, które omówimy nieco dalej.
      Masz już system i cząsteczkę, którą możesz w nim umieścić, ale nie jesteś jeszcze gotowy do tworzenia wspaniałych efektów! Musisz jeszcze zdefiniować właściwości cząstki, czyli jej wygląd - prędkość, obrót, alfa itd. Istnieje wiele szczegółów, których można użyć do zdefiniowania efektu cząsteczkowego, dlatego poniżej znajduje się przegląd najważniejszych ustawień, a następnie fragment kodu i strona GML Visual, które wykorzystują wszystkie te ustawienia:
      
        shape: Kształt cząstki to wbudowany adres sprite, którego będzie ona używać, przy czym domyślnie jest to stała pt_shape_pixel. Dostępna jest także funkcja umożliwiająca dodanie w razie potrzeby niestandardowej cząstki - part_type_sprite() - lub akcję Ustaw sprajt cząstki.
        rozmiar: Ustawia parametry rozmiaru dla danego typu cząstki. Określa się minimalny rozmiar początkowy, maksymalny rozmiar początkowy oraz przyrost rozmiaru w każdym kroku (w celu zmniejszenia rozmiaru należy użyć liczby ujemnej). Jest to wartość skalarna, która w równym stopniu modyfikuje skalę x/y obrazu podstawowego.
        kolor: Ustawia kolor cząstki, jeśli używany jest jeden kolor. Jeśli podano dwa lub trzy kolory, będzie to mieszanka kolorów, przechodząca z jednego do drugiego w czasie życia cząstki.
        alfa: Ustawia wartość alfa dla cząstki w zakresie od 0 do 1. Jeśli zostanie podana pojedyncza wartość, będzie to alfa cząstki, jeśli zostaną podane dwie lub trzy wartości, alfa będzie mieszać się między nimi przez cały czas życia cząstki.
        prędkość: Ustawia właściwości prędkości dla danego typu cząstki. Określasz minimalną i maksymalną prędkość, a podczas tworzenia cząstki wybierana jest losowa wartość pomiędzy podanymi granicami. Można określić wzrost prędkości w każdym kroku, a nawet użyć liczb ujemnych, aby spowolnić cząstkę (prędkość nigdy nie będzie mniejsza niż 0).
        kierunek: Ustawia właściwości kierunku dla danego typu cząstki. Ponownie określasz zakres kierunków (w stopniach przeciwnych do ruchu wskazówek zegara - 0 oznacza ruch w prawo, 90 oznacza ruch w górę itd...). Na przykład, aby cząstka poruszała się w losowym kierunku, należy wybrać wartości minimalne 0 i maksymalne 360. Dla każdego kroku można określić wzrost kierunku (może być również ujemny).
        orientacja: Ustawia właściwości kąta orientacji dla typu cząstki. Określasz minimalny kąt, maksymalny kąt oraz zwiększenie każdego kroku. Można także określić, czy podany kąt powinien być względny względem bieżącego kierunku ruchu, czy bezwzględny, np.: ustawienie wszystkich wartości na 0, ale względnej na true spowoduje, że orientacja cząstki będzie dokładnie zgodna z adresem path cząstki.
        mieszanie: Określa, czy dla danego typu cząstki ma być używane mieszanie addytywne czy normalne . Ustawia się to w funkcji, gdy używana jest strona GML, lub jako część inicjalizacji cząsteczek, gdy używana jest strona GML Visual. Mieszanie addytywne oznacza, że cząstki będą korzystać z trybu mieszania bm_add, nadając im "świecący" wygląd w miejscach, w których się nakładają, a także mieszając je z wszystkim, co jest narysowane pod nimi (sprites, tła, tiles, itd...) - jest to bardzo przydatne w przypadku efektów ognia i magii (na przykład), ale najlepiej wyłączyć je w przypadku czegoś takiego jak dym. Poeksperymentuj, aby zobaczyć różnice! Zwróć uwagę, że włączenie tej funkcji przerwie podział na partie texture podczas tworzenia cząsteczek, a zatem do ich narysowania będzie potrzebnych więcej partii na krok - warto to rozważyć, ponieważ może to wpłynąć na wydajność, zwłaszcza w urządzeniach przenośnych.
        czasżycia: Określa limit czasu życia cząstek danego typu w krokach (klatkach gry). Podobnie jak poprzednie ustawienia, ma to wartość minimalną i maksymalną, a cząstki będą trwać losową liczbę kroków w ramach tych wartości. Tak więc, jeśli czas życia wynosi 30 min i 30 max, cząstka będzie istnieć przez dokładnie 30 kroków, ale jeśli czas życia wynosi 20 min i 60 max, każda cząstka będzie istnieć przez losową liczbę kroków pomiędzy 20 a 60.
      
      Zanim przedstawimy kod definiujący cząsteczkę, porozmawiajmy przez chwilę o "wiggle"... Wierzcie lub nie, ale "wiggle" jest właściwością cząstki i można ją ustawić dla wielu z powyższych ustawień indywidualnie. Gdy widzisz "wiggle" jako argument funkcji lub akcji cząsteczki, oznacza to, że jeśli wpiszesz liczbę z przedziału od 1 do 20, cząsteczka będzie "wiggle" lub będzie się wahać między minimalną a maksymalną wartością tej właściwości, przy czym 1 oznacza powolne wiggle, a 20 - bardzo szybkie. Zatem minimalna prędkość cząstki równa 2, maksymalna 5, a prędkość ruchu równa 20, będzie bardzo szybko oscylować między prędkościami minimalną i maksymalną w czasie życia każdej utworzonej cząstki.
      UWAGA: Istnieją także inne, pomniejsze właściwości cząsteczek, których tutaj nie opisujemy, aby na początek wszystko było jak najprostsze. Szczegółowe informacje o właściwościach cząsteczek można znaleźć na odpowiednich stronach.
      Przyjrzyjmy się teraz kodowi, który definiuje cząstkę:
      // This defines the particle's shape
        
        part_type_shape(global.Particle1,pt_shape_pixel);
        
        
        // This is for the size
        
        part_type_size(global.Particle1,1,1,0,2);
        
        
        // This sets its colour. There are three different codes for this
        
        part_type_color1(global.Particle1,c_white);
        
        
        // This is its alpha. There are three different codes for this
        
        part_type_alpha1(global.Particle1,1);
        
        
        // The particles speed
        
        part_type_speed(global.Particle1,0.50,2,-0.10,0);
        
        
        // The direction
        
        part_type_direction(global.Particle1,0,359,0,20);
        
        
        // This changes the rotation of the particle
        
        part_type_orientation(global.Particle1,0,0,0,0,true);
        
        
        // This is the blend mode, either additive or normal
        
        part_type_blend(global.Particle1,1);
        
        
        // This is its lifespan in steps
        
        part_type_life(global.Particle1,5,30); 
      Aby utworzyć taką samą definicję cząstki w witrynie GML Visual, potrzebne są następujące działania:
      I to już wszystko! Zdefiniowaliśmy nasze cząstki i są one gotowe do użycia.
       
    
    Tworzenie cząsteczek bezpośrednio w grze
    
      Cząstki można tworzyć na kilka sposobów, a każdy z nich ma swoje wady i zalety. Można użyć emiterów do wybuchu lub strumienia cząstek, można też tworzyć cząstki bezpośrednio w punkcie. To, którego z nich użyjesz, zależy od tego, co chcesz osiągnąć i jaki efekt chcesz uzyskać, ale zaczniemy od najprostszego z nich, czyli od bezpośredniego tworzenia cząstek. W witrynie GML użylibyśmy następującej funkcji:
      part_particles_create(global.P_System, x, y, global.Particle1, 10);
      a w GML Visual byłoby to:
      Ten pojedynczy kod/akcja utworzy 10 cząstek w podanych współrzędnych x/y typu "Cząstka1" z naszego globalnego systemu. Proste! Wspaniałą rzeczą w tej linii kodu/akcji jest to, że może być użyta gdziekolwiek bez żadnego zamieszania. Na przykład, jeśli umieścisz ją w globalnym zdarzeniu naciśnięcia lewego przycisku myszy w object i zmienisz wartości x/y dla pozycji mouse_x/y, będzie ona tworzyć cząsteczki w pozycji myszy za każdym razem, gdy naciśniesz przycisk. Jeśli masz rakietę, możesz umieścić to w zdarzeniu kroku i mieć cząsteczki dymu pojawiające się co krok (choć 1 lub 2 byłyby lepsze niż 10!). Można nawet zlecić tworzenie cząsteczek na pewnym obszarze, na przykład zmieniając losowo współrzędne x/y:
      repeat(50)
        
        {
        
        var xx = x + 20 - random(40);
        
        var yy = y + 20 - random(40);
        
        part_particles_create(global.P_System, xx, yy, global.Particle1, 1);
        
        }
      Powyższy kod utworzy 50 cząstek w losowym miejscu kwadratowego obszaru o boku 40px.
       
    
    Tworzenie cząstek za pomocą emiterów
    
      Skoro wyjaśniliśmy już prosty sposób tworzenia cząstek, przejdźmy teraz do nieco bardziej skomplikowanej metody, czyli do użycia emiterów. Emitery to kolejna część systemu cząsteczek, która musi być zdefiniowana przed użyciem, więc stworzymy globalny emiter, tak samo jak zrobiliśmy to dla systemu i cząsteczek. Musimy także zdecydować, czy emiter ma być statyczny (nie poruszający się), czy też nie, oraz czy cząstki mają być rozsadzane czy strumieniowane , a także na jakim obszarze i w jakim rozkładzie emiter ma być używany.
      Co to wszystko oznacza? Cóż, emiter statyczny to taki, który można zdefiniować raz i zapomnieć o nim, ponieważ nie będzie się nigdzie poruszał przez cały czas trwania gry, np. pomyśl o ognisku z polan - nie porusza się, tylko emituje płomienie, więc jest statyczny, ale kula ognia wymaga emitora dynamicznego i będzie się poruszać po ekranie. Jeśli chodzi o wybuch lub strumień, to wybuch jest jednorazową eksplozją cząstek, podczas gdy strumień jest właśnie tym - stałym strumieniem cząstek na każdym kroku. Jeśli chodzi o obszar i rozmieszczenie, w emiterach można zdefiniować obszar emisji cząstek (może to być prostokąt, elipsa, romb lub linia), a także krzywą rozmieszczenia (gaussian, inverse gaussian lub liniowa).
      Na poniższych ilustracjach przedstawiono różne rodzaje kształtu obszaru dostępne dla emiterów:
       
       
       
      
        
        Krzywe rozkładu (liniowa, gaussowska i odwrotna gaussowska) są przedstawione na ilustracji:
      
      Poniżej znajduje się przykład kodu/działań wymaganych do zdefiniowania dwóch emiterów, które normalnie zostałyby umieszczone w zdarzeniu Create Event kontrolera object, zaraz po zdefiniowaniu systemu cząsteczek. Jeden z nich będzie statyczny i będzie rozsiewał cząsteczki na obszarze całej strony room, a drugi będzie dynamiczny i będzie podążał za myszą oraz wybuchał co 30 kroków z małej elipsy:
       
      global.Particle1_Emitter1 = part_emitter_create(global.P_System);
        
        global.Particle1_Emitter2 = part_emitter_create(global.P_System);
        
        
        // Set up the area that will emit particles
        
        part_emitter_region(global.P_System, global.Particle1_Emitter1, 0, room_width, 0, room_height, ps_shape_rectangle, ps_distr_linear);
        
        part_emitter_region(global.P_System, global.Particle1_Emitter2, mouse_x-10, mouse_x+10, mouse_y-10, mouse_y+10, ps_shape_ellipse, ps_distr_gaussian);
        
        
        // Set the first to stream 10 particles every step
        
        part_emitter_stream(global.P_System, global.Particle1_Emitter1, global.Particle1, 10);
        
        
        // This can now be forgotten as it will function until told to stop...
        
        // Set the alarm[0] event to burst the emitter2 particles...
        
        alarm[0] = 30; 
      Tworzymy więc dwa emitery cząsteczek, które są przypisane do systemu cząsteczek utworzonego na początku. Funkcje/akcje tworzące te emitery pozwalają nam określić obszar w witrynie room, na którym będą emitować cząstki, a także podać typ cząstek, które mają emitować, oraz kształt i rozmieszczenie, jakie mają być zastosowane w określonym obszarze. Funkcje/działania zwracają wartość liczbową, która jest identyfikatorem emitera, i przechowują ją w zmiennej, abyśmy mogli użyć kolejnych funkcji emitera do wycelowania w te emitery.
      Teraz mamy kod/GML Visual do strumieniowania cząstek (cząstki te będą emitowane w każdym kroku gry, bez konieczności robienia czegokolwiek innego), ale chcemy też dodać zdarzenieAlarm[0], aby cząstki wybuchały w określonych odstępach czasu:
      part_emitter_region(global.P_System, global.Particle1_Emitter2, mouse_x - 10, mouse_x + 10, mouse_y - 10, mouse_y + 10, ps_shape_ellipse, ps_distr_gaussian);
        
        part_emitter_burst(global.P_System, global.Particle1_Emitter2, global.Particle1, 30);
        
        alarm[0] = 30;
      Wybuch cząstek to po prostu jednorazowa eksplozja cząstek z emitera, a nie ich ciągły strumień w każdym kroku gry.
      Ale co zrobić, jeśli chcesz, aby kilka stron objects emitowało cząsteczki? Globalny emiter może znajdować się tylko w jednym miejscu naraz, więc trzeba by utworzyć lokalne emitery w każdym object. Emitory te nadal będą korzystać z globalnego systemu cząsteczek i wszystkich cząsteczek, które się w nim znajdują, ale mogą mieć różne kształty i rozmiary oraz poruszać się wraz z object, co czyni je idealnymi dla rakiet, pocisków i innych rzeczy. Kod, którego użyjesz, będzie dokładnie taki sam jak powyżej, ale bez przedrostka "global" przed nazwami emiterów.
      To tyle, jeśli chodzi o tworzenie cząsteczek, ale jest jeszcze jedna bardzo ważna rzecz... Sprzątanie po zakończeniu pracy z cząsteczkami.
       
    
    Sprzątanie
    
      Jak wspomniano na początku, raz utworzony system cząsteczek (wraz z cząsteczkami, emiterami itp.) jest zapisywany w pamięci, aby można go było natychmiast użyć. Świetnie, ale co się stanie, gdy ponownie uruchomisz grę? Albo gdy twój gracz umrze i zaczniesz grę od nowa room? Cóż, jeśli nie zarządzasz grą w odpowiedni sposób, może dojść do wycieku pamięci. Dzieje się tak, gdy coś zostało utworzone i zużywa pamięć, ale zostało "odesłane", co oznacza, że GameMaker nie ma już do tego dostępu. Takie coś będzie powoli zużywać pamięć i powodować opóźnienia w grze, a nawet blokować komputer, powodując awarię gry. Jest to dość częsty problem u początkujących użytkowników systemów cząsteczkowych.
      Jak można tego uniknąć? Cóż, GameMaker posiada funkcje kodu GML oraz akcje wizualne GML, które usuwają systemy cząsteczek oraz ich emitery i cząsteczki z pamięci, gdy nie są używane. Przy odrobinie planowania podczas używania poniższego kodu/akcji można łatwo zapobiec temu potencjalnemu problemowi.
      Pierwszą rzeczą, którą musisz zrobić, jest określenie, gdzie utworzysz system i jak będziesz go używać. Mógłbyś utworzyć globalny system w zdarzeniu startowym gry na stronie object, która znajduje się na pierwszej stronie room (np. menu lub ekran tytułowy), ale oznacza to, że po ponownym uruchomieniu gry przy użyciu funkcji game_restart() zostanie on odtworzony i spowoduje wyciek pamięci. Możesz też utworzyć system lokalny w instancji w dowolnej witrynie room, ale również w tym przypadku, jeśli opuścisz witrynę room, system będzie niedostępny i spowoduje wyciek pamięci. Aby tego uniknąć, należałoby umieścić coś takiego w pliku Zakończenie gry lub w Zdarzenie czyszczenia swojego obiektu:
      part_type_destroy(global.Particle1);
        
        part_emitter_destroy(global.P_System, global.Particle1_Emitter);
        
        part_emitter_destroy(global.P_System, global.Particle2_Emitter);
        
        part_system_destroy(global.P_System);
      Spowoduje to usunięcie zdefiniowanych cząsteczek, emiterów, a następnie systemu z pamięci, gotowego do ponownego uruchomienia gry lub zmiany adresu room. Pamiętaj, że po zastanowieniu się, gdzie najlepiej stworzyć system, zastanów się też, gdzie najlepiej go zniszczyć!
       
    
     
    Teraz znasz już podstawy cząsteczek, systemów cząsteczek i emiterów, możesz więc dodać je do swojej gry! Zanim jednak zaczniesz dodawać efekty cząsteczek do wszystkiego, pamiętaj, że choć cząsteczki mniej obciążają procesor niż instancje, nie są rozwiązaniem na wszystko, ponieważ powodują lagi, jeśli masz ich tysiące naraz. Najlepiej jest eksperymentować i używać ich ostrożnie, aby "wypełnić" wizualnie grę i nadać jej nieco więcej uroku bez przesady.
     
     
    
      
        
          Powrót: Informacje dodatkowe
          Następny: Przewodnik po używaniu shaderów
        
      
      © Copyright YoYo Games Ltd. 2021 Wszystkie prawa zastrzeżone.
    
    
