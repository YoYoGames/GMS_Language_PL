
  
  Przewodnik po prymitywach i Vertex Budowanie
  W tym podręczniku omówiono pokrótce sposób tworzenia i używania prymitywów przy użyciu niestandardowych formatów wierzch ołków i buforów wierzchołków. 
  Na ogół, gdy zaczynasz pracę z 3D, efektami specjalnymi, złożonymi procesami rysowania lub stroną shaders, nie musisz się zbytnio przejmować używanym formatem vertex, ponieważ GameMaker automatycznie skonfiguruje i przepuści dane wierzchołków. Czasami jednak konieczne jest utworzenie własnych danych vertex i odpowiednie ich sformatowanie, zwłaszcza gdy chcesz zwiększyć szybkość lub przekazać dodatkowe informacje. Na przykład standardowy format vertex zawiera pozycję 3D x, y, z, kolor (z alfą) oraz współrzędne UV texture. Gdybyś sam tworzył takie dane, wyglądałyby one następująco
  vertex_format_begin();
    vertex_format_add_position_3d();
    vertex_format_add_colour();
    vertex_format_add_textcoord();
    my_format = vertex_format_end();
  Jeśli jednak używasz (na przykład) adresu shader tylko do manipulowania położeniem adresu vertex, nie ma potrzeby przekazywania danych o kolorze ani adresu texture. W takim przypadku należy utworzyć własny format w następujący sposób:
  vertex_format_begin();
    vertex_format_add_position_3d();
    my_format = vertex_format_end();
  W sumie istnieje pięć różnych atrybutów vertex, których można użyć podczas definiowania formatu vertex:
  
    Kolor
    Normalna
    Pozycja
    Pozycja 3D
    Współrzędna tekstury
  
  Ogólnie rzecz biorąc, w formacie należy zawsze podawać pozycję lub pozycję 3D, ale wszystkie pozostałe elementy są opcjonalne.
  Należy pamiętać, że po utworzeniu formatu vertex kolejność, w jakiej zostały zdefiniowane atrybuty vertex, musi być przestrzegana podczas tworzenia prymitywów. Tak więc, jeśli zdefiniowałeś format vertex jako pozycję, kolor i współrzędną texture,  musisz dodać te atrybuty do prymitywu w tej samej kolejności, w przeciwnym razie pojawi się błąd. Należy również pamiętać, że jak każdy inny zasób dynamiczny, format vertex wymaga pamięci i dlatego powinien być usuwany, gdy nie jest potrzebny, za pomocą funkcji vertex_format_delete().
  Wszystkie prymitywy, które zostaną zbudowane, są przechowywane w buforze wierzchołków. Bufor ten musi być utworzony wcześniej, a następnie odwołują się do niego funkcje używane do budowania prymitywów. Strona vertex buffer może być używana tyle razy, ile jest to konieczne do tworzenia różnych prymitywów, lub może zostać "zamrożona", aby zachować określony typ prymitywu na czas trwania gry lub poziomu (jest to najszybsze rozwiązanie, więc jeśli wiesz, że zbudowany prymityw nie ulegnie zmianie, zawsze powinieneś korzystać z tej opcji).
  Przykład budowy prymitywu pojedynczego trójkąta jest przedstawiony w poniższym kodzie:
  // CREATE EVENT
    v_buff = vertex_create_buffer();
    vertex_begin(v_buff, global.my_format);
    vertex_position(v_buff, 10, 10);
    vertex_colour(v_buff, c_white, 1);
    vertex_texcoord(v_buff, 0, 0);
    vertex_position(v_buff, 110, 10);
    vertex_colour(v_buff, c_white, 1);
    vertex_texcoord(v_buff, 1, 0);
    vertex_position(v_buff, 110, 110);
    vertex_colour(v_buff, c_white, 1);
    vertex_texcoord(v_buff, 1, 1);
    vertex_end(v_buff);
    
    // DRAW EVENT
    var tex = sprite_get_texture(spr_Background, 0);
    shader_set(shd_shimmer);
    vertex_submit(v_buff, pr_trianglelist, tex);
    shader_reset();
  
  W tym przypadku najpierw tworzymy nasz wierzchołek buffer w zdarzeniu Create Event instancji, a następnie rozpoczynamy definicję różnych wierzchołków, które tworzą nasz prymityw trójkąta, podając pozycję, kolor i współrzędną UV texture dla każdego z trzech punktów, których chcemy użyć. Następnie kończymy definicję vertex i wiemy, że strona vertex buffer z danymi vertex jest przechowywana w zmiennej "v_buff".  
  UWAGA: Jeśli zawartość strony buffer ma być stale aktualizowana, można by utworzyć stronę buffer, przekazać jej dane vertex, a następnie ponownie ją zniszczyć - po narysowaniu - wszystko w tym samym kroku.
  Następnie w zdarzeniu Draw Event rysujemy zawartość strony vertex buffer za pomocą strony shader. Jest to bardzo prosty przykład i w zasadzie tak właśnie działa GameMaker, tzn. gdy rysujesz stronę sprite, strona GameMaker tworzy stronę vertex buffer z czterema wierzchołkami tworzącymi dwa trójkąty (które tworzą kwadrat, zwany też "quadem"), a strona textures tworzy z tych dwóch trójkątów obraz sprite. Podczas rysowania tej strony sprite przesyłamy na ekran obraz vertex buffer i jego zawartość.
  Po przesłaniu strony vertex buffer do narysowania podajemy typ prymitywu. Prymityw może być punktem, listą lub paskiem linii albo listą lub paskiem trójkątów, ale nie wolno używać trójkątów, ponieważ większość urządzeń przenośnych nie akceptuje tego typu prymitywów. Nie zapomnij sformatować strony vertex buffer poprawnie dla typu prymitywu, który ma być użyty do jej narysowania. Na przykład, rysowanie prymitywu dwóch trójkątów jako listy trójkątów wymaga 6 punktów, ale jako paska trójkątów wymaga tylko 4 punktów. To, którego typu użyjesz, zależy od tego, co chcesz narysować i jaki efekt chcesz osiągnąć.
  Ostatnią ważną kwestią, na którą należy zwrócić uwagę, używając w ten sposób własnej strony vertex buffers, jest to, jak wpływa ona na partie wierzchołków wysyłane do GPU. Gdy tworzysz vertex buffer, tworzysz najniższy poziom danych graficznych, więc podczas rysowania wszystko, co się dzieje, to fakt, że GameMaker wysyła buffer bezpośrednio do karty graficznej. Z tego powodu, jeśli chcesz uzyskać lepszy podział na partie, musisz to zrobić samodzielnie i przechowywać elementy, które chcesz podzielić na partie, w tej samej witrynie buffer.
  Jak już wspomniano powyżej, formaty vertex są tworzone poprzez łączne wykorzystanie następujących 5 typów atrybutów (dodawanych za pomocą odpowiedniej funkcji vertex_format_add_* ):
  
    Kolor
    Normalna
    Pozycja
    Pozycja 3D
    Współrzędna tekstury
  
  W języku GLSL ES shader rodzaje te są rozpoznawane za pomocą następujących 4 atrybutów:
  
    Kolor
    Normalna
    Pozycja
    Współrzędna tekstury
  
  Może to wyglądać dziwnie, ponieważ wydaje się, że w naszym formacie vertex możemy określić więcej rodzajów atrybutów niż w vertex shader. Jednak w formacie shader Position i 3D Position są traktowane jako te same atrybuty, z tym wyjątkiem, że Position ma mieć tylko współrzędne "x" i "y", podczas gdy 3D Position ma współrzędne "x", "y" i "z". Jak więc odwzorować to, co jest w formacie vertex, na sposób definiowania atrybutów w shader? Na początek przyjrzyjmy się typowemu zestawowi atrybutów z domyślnego shadera:
   
  attribute vec3 in_Position;        // (x,y,z)
    //attribute vec3 in_Normal;        // (x,y,z) unused in this shader.
    attribute vec4 in_Colour;          // (r,g,b,a)
    attribute vec2 in_TextureCoord;    // (u,v)
  A oto fragment kodu, który ustawia format vertex kompatybilny z tym shaderem:
  vertex_format_begin();
    vertex_format_add_position_3d();
    vertex_format_add_colour();
    vertex_format_add_textcoord();
    my_format = vertex_format_end();
  W jaki sposób atrybut shader jest dopasowywany do typu formatu vertex? Opiera się to na konwencji nazewnictwa:
  
    "in_Position" mapy do vertex_format_add_position/_3d()
    "in_Colour" mapy do vertex_format_add_colour()
    "in_TextureCoord" mapy do vertex_format_add_texcoord()
  
   Sytuacja komplikuje się, gdy mamy wiele atrybutów tego samego rodzaju, ale nadal stosujemy tę samą konwencję nazewnictwa. Przyjrzymy się teraz dostarczaniu dodatkowych współrzędnych koloru i tekstury, ponieważ w formacie shader lub vertex może być tylko jeden atrybut Pozycja i jeden atrybut Normalny, ale może być wiele atrybutów koloru lub texture.
  Podczas dodawania dodatkowych atrybutów koloru do strony shader na końcu atrybutu shader należy dodać numer wskazujący, do którego wpisu w formacie vertex atrybut ten jest przypisany. Oto przykład - najpierw format vertex:
  vertex_format_begin();
    vertex_format_add_position_3d();
    vertex_format_add_colour();
    vertex_format_add_colour();
    vertex_format_add_textcoord();
    my_format = vertex_format_end();
  A teraz powiązane atrybuty shader:
  attribute vec3 in_Position;      // (x,y,z)
    attribute vec4 in_Colour0;       // (r,g,b,a)
    attribute vec4 in_Colour1;       // (r,g,b,a)
    attribute vec2 in_TextureCoord;  // (u,v)
  W tym przypadku adres in_Colour0 odpowiada pierwszemu adresowi vertex_format_add_colour(), a adres in_Colour1 odpowiada drugiemu.
  Współrzędne tekstury są traktowane nieco inaczej niż kolor. Zasadniczo wszystko, co nie ma nazwy in_Position, in_Normal lub jednego z atrybutów in_Colour[0 ... ], jest traktowane jako współrzędna texture. Kolejność, w jakiej są one zdefiniowane na liście atrybutów w witrynie shader, określa, do którego atrybutu w formacie vertex są one mapowane. Patrz następujący przykład GML:
  vertex_format_begin();
    vertex_format_add_position_3d();
    vertex_format_add_colour();
    vertex_format_add_textcoord();
    vertex_format_add_textcoord();
    vertex_format_add_textcoord();
    my_format = vertex_format_end();
  Kod shader wyglądałby mniej więcej tak:
  attribute vec3 in_Position;      // (x,y,z)
    attribute vec4 in_Colour;        // (r,g,b,a)
    attribute vec2 in_myTexcoord;    // (u,v)
    attribute vec2 in_TextureCoord;  // (u,v)
    attribute vec2 in_Something;     // (u,v)
  W tym przykładzie adresy in_myTexcoord, in_TextureCoord i in_Something odpowiadają trzem kolejnym atrybutom współrzędnych texture zdefiniowanym w formacie vertex.
  Pełną listę wszystkich funkcji potrzebnych do tworzenia formatów vertex, vertex buffers i prymitywów można znaleźć na następnej stronie:
  
    Prymitywy i Vertex Formaty
  
   
   
   
  
    
      
        Powrót: Informacje dodatkowe
        Następny: Przewodnik korzystania z Blendmodes
      
    
    © Copyright YoYo Games Ltd. 2021 Wszystkie prawa zastrzeżone.
  
  
  

