
  
  Tworzenie rozszerzenia
  Aby utworzyć extension, należy najpierw kliknąć prawym przyciskiem myszy na  w dowolnym miejscu w Przeglądarce zasobów i wybrać Utwórz -> Rozszerzenie. Spowoduje to otwarcie właściwości Extension dla nowo utworzonej strony asset w przestrzeni roboczej:
  Jeśli nie jest ona widoczna, można dwukrotnie kliknąć witrynę Extension asset w przeglądarce Asset, aby otworzyć jej okno właściwości, lub ustawić na niej ostrość, gdy jest już otwarta.
  W tym miejscu można też nadać extension nazwę (zgodnie z przyjętą konwencją: tylko litery/liczby i żadnych symboli specjalnych z wyjątkiem podkreślenia "_"). Można także ustawić numer wersji dla extension.
  W sekcji "Kopie do" można wybrać platformy, na które ma być eksportowana strona extension. W przypadku zwykłej strony GML extension nie musisz się o to martwić, ponieważ będzie ona działać na wszystkich platformach. Jeśli jednak tworzysz stronę extension przeznaczoną dla konkretnej platformy (np. Android), musisz się upewnić, że nie zostanie ona wyeksportowana na żadną niekompatybilną platformę (np. iOS, konsole itp.).
  Pliki placeholder
  Aby dodać plik do nowej strony extension, należy kliknąć ikonę menu  i wybrać plik zastępczy ("Add Placeholder") lub zaimportować rzeczywisty plik wymagany dla platformy docelowej ("Add File"):
  
  Ogólny" plik zastępczy to plik, który może być dowolnego typu, z wyjątkiem tych, które są wymagane przez konkretne platformy (na przykład nie ma plików DLL ani SO ), i nie będzie używany, chyba że jako plik "linkera" do połączenia zestawu funkcji lub stałych z danym adresem extension (zasadniczo jest on używany tylko z adresami iOS i Android extensions, co jest wyjaśnione w poniższych sekcjach dotyczących tych celów). Można też dodać pliki zastępcze "GML" i "JS" do bardziej specyficznych zastosowań.
  Dodawanie plików
  Zazwyczaj nie ma potrzeby używania zmiennych, chyba że budujesz dla iOS i Android, dlatego należy wybrać opcję "Dodaj plik", aby dodać jeden z poniższych plików w zależności od platformy docelowej, dla której są przeznaczone:
  
    .gml: Jest to plik przygotowany wyłącznie za pomocą strony GameMaker Language i jest kompatybilny ze wszystkimi platformami.
    .js: Jest to format JavaScript extension i jest kompatybilny tylko z docelowym HTML5.
    .dll: Jest to format biblioteki dynamicznego łącza extension i jest zgodny tylko z platformami Windows, UWP i Xbox (każda z nich wymaga innego pliku *.dll zgodnego z jej specyfikacją).
    .dylib: Jest to odpowiednik biblioteki DLL w systemie Mac i jest kompatybilny tylko z systemem docelowym Mac (nie iOS).
    .so: To jest Linux odpowiednik biblioteki DLL i jest kompatybilny tylko z celem Ubuntu (Linux).
    .prx: Jest to format pliku służącego do dodawania funkcji do celu PlayStation (każdy cel będzie wymagał innego pliku *.prx zgodnego z jego specyfikacją).
  
  Zauważysz, że nie ma typu pliku dla systemów Android i iOS, ponieważ ich konfiguracja jest nieco inna. W dalszej części rozdziału znajdziesz wyjaśnienia, jak je skonfigurować, ale najpierw przyjrzyjmy się tworzeniu ogólnej strony GML extension dla każdej z platform docelowych, ponieważ proces jest taki sam dla wszystkich z nich.
  Tworzenie rozszerzenia GML 
  Na początek należy utworzyć plik, który będzie używany. W przypadku GML extension będzie to plik tekstowy (zapisany za pomocą .gml extension) o następującym formacie:
  #define c_alice_blue
    return make_color_rgb(240,248,255);
    
    
    #define instance_create_colour
    var i = instance_create_layer(argument0, argument1, argument2, argument3);
    with (i)
    {
        image_blend = argument3;
    }
    return i;
  
  Jak widać, każdą sekcję rozpoczynamy od wywołania #define, które w powyższym przykładzie służy do zdefiniowania dwóch funkcji. Przyjrzyjmy się poszczególnym częściom zdefiniowanej funkcji:
  
    Polecenie #define służy do definiowania nowej funkcji o podanej nazwie;
    Po tej deklaracji następuje kod funkcji, który używa zmiennych argument0, argument1, itd. do uzyskania dostępu do argumentów przekazywanych do funkcji w momencie jej wywołania;
    Na końcu znajduje się instrukcja return która jest używana do zwracania danych z extension z powrotem do kodu GML, w którym wywołano funkcję.
  
  Gdybyś pisał stronę DLL lub JavaScript extension, proces byłby podobny, ale w języku odpowiednim dla formatu pliku z danym rozszerzeniem.
  Po wykonaniu tych czynności należy dodać plik do witryny extension (używając opcji "Add File" (Dodaj plik)), co spowoduje wyświetlenie nowego okna w witrynie Extensions Properties (Właściwości pliku):
  
  W tym miejscu należy wybrać platformę docelową dla extension (w przypadku GML należy wybrać wszystkie), a także zmienić nazwę pliku extension i ustalić kilka innych szczegółów, którymi zajmiemy się za chwilę.
  UWAGA: Dodanie pliku do extension powoduje skopiowanie go do katalogu projektu, co oznacza, że wszelkie dalsze zmiany muszą być wprowadzane do tej kopii, aby były widoczne w grze. Kopię można znaleźć, klikając prawym przyciskiem myszy na stronie extension w przeglądarce Asset i wybierając opcję "Otwórz w Eksploratorze".
  Dodawanie funkcji
  Edytor powinien być automatycznie wypełniony funkcjami zawartymi w naszym pliku GML, ale jeśli tak nie jest, można je dodać ręcznie, klikając przycisk menu Funkcje  i wybierając potrzebne funkcje:
  
  Wybranie opcji "Dodaj funkcję" umożliwia dodanie funkcji do witryny extension, którą można następnie wywoływać w witrynie GameMaker Studio 2 w taki sam sposób, jak każdą inną funkcję wbudowaną. Po dodaniu funkcji otworzy się następujące okno, w którym można określić właściwości funkcji (można też dwukrotnie kliknąć funkcję, aby ją otworzyć):
  
  Na powyższym rysunku wypełniliśmy edytor funkcji szczegółami funkcji instance_create_colour(), którą zdefiniowaliśmy w naszym pliku GML extension (zauważ, że to okno edytora funkcji nie służy tylko do definiowania funkcji GML - będzie ono takie samo dla wszystkich typów extension ). Omówimy teraz wszystkie opcje, które można zdefiniować w funkcji:
  
    Zauważ, że nadaliśmy funkcji nazwę, która będzie używana podczas wywoływania funkcji w projekcie; zauważ, że nazwa ta nie musi być zgodna z nazwą użytą w extension - możesz nadać jej dowolną nazwę, a następnie użyć pola External Name, aby połączyć ją z rzeczywistą nazwą zdefiniowaną w rozszerzeniu:
    Poniżej znajduje się sekcja służąca do definiowania tekstu pomocy , czyli tekstu, który będzie wyświetlany w oknie podręcznym uzupełniania kodu oraz w tekście pomocniczym na dole edytora kodu.
    Następnie można określić typ zwracany, którym może być double (liczba rzeczywista zmiennoprzecinkowa ) lub string; jeśli funkcja zewnętrzna nie zwraca niczego, to nie ma to znaczenia.
    W tym miejscu definiuje się argumenty, które będą przyjmowane przez funkcję. Argumenty te mogą być zarówno podwójne , jak i łańcuchowe. Można je dodawać, klikając przycisk dodaj , i usuwać, klikając przycisk usuń .
      
      Jeśli funkcja może przyjmować zmienną liczbę argumentów (czyli ma kilka argumentów opcjonalnych), należy zaznaczyć pole wyboru "Argumenty o zmiennej długości" na dole okna.
    
  
  UWAGA: Jeśli funkcja jest częścią rodzimego extension dla Windows, Mac lub Ubuntu (dll, dylib lub so odpowiednio) i ma więcej niż cztery argumenty, wszystkie argumenty muszą być tego samego typu.
  Po wykonaniu wszystkich tych czynności funkcja jest gotowa do użycia w projekcie; pojawi się teraz w autouzupełnianiu i będzie oznaczona kolorami:
  Zdefiniowane funkcje można również ustawić jako funkcje początkowe (Init) lub końcowe(Final), co oznacza, że będą one wywoływane automatycznie przy rozpoczęciu gry (Init) i po jej zakończeniu (Final).
  WAŻNE! Wszystkie platformy obsługują wywołanie funkcji Init, ale nie wszystkie wykonują wywołanie funkcji Final. Dzieje się tak dlatego, że niektóre platformy po prostu zamykają aplikację, nie dając żadnego powiadomienia ani czasu na wywołanie tej funkcji. Najczęściej dotyczy to platform iOS, Android, HTML5, PlayStation i Xbox.
  Makra
  Inną dostępną opcją jest utworzenie makra. Makro może być zarówno stałą wartością, jak i krótkim fragmentem kodu (więcej informacji o makrach można znaleźć tutaj). Na przykład możemy usunąć funkcję c_alice_blue z naszego wcześniej zdefiniowanego rozszerzenia GML i zamiast niej utworzyć makro. Aby utworzyć makro, wystarczy kliknąć przycisk "Makra" w oknie Właściwości Extension, co spowoduje otwarcie następującego okna:
  
  Edytor jest dość prosty: podajesz nazwę makra i jego stałą wartość lub krótki wiersz kodu. Zwróć uwagę, że jeśli makro jest linią kodu, to będzie ona obliczana przy każdym wywołaniu makra.
  Pliki proxy
  W przypadku pracy z wieloma platformami docelowymi warto zauważyć, że można utworzyć pojedynczy plik extension z jednym zestawem funkcji/makr, który będzie działał na wszystkich platformach. W tym celu należy dodać do gry tylko jedną z bibliotek linków jako extension, a pozostałe umieścić na liście plików proxy w oknie Właściwości rozszerzenia.
  Na przykład, powiedzmy, że mamy Windows extension z  dll "Haggis.dll". Wystarczy powielić tę stronę  dll jako Mac  DyLib, nadając jej nazwę "libHaggis.dylib" i upewniając się, że nazwy funkcji wewnętrznych odpowiadają nazwom funkcji z oryginalnej strony Windows  dll. Ta strona  DyLib Następnie należy dodać ją do plików proxy i ustawić na eksportowanie podczas uruchamiania gry na komputerze Mac, a witryna GameMaker Studio 2 będzie automatycznie używać jej podczas wywoływania funkcji extension.
  Aby dodać plik proxy, wystarczy kliknąć przycisk  w oknie Właściwości wybranego pliku zasobów i przejść do jego lokalizacji. Po jego dodaniu może być konieczne zaktualizowanie celów rozszerzenia, aby dodać odpowiedni moduł, a przy następnym uruchomieniu gry zostanie ona uwzględniona jako plik proxy dla danej platformy. Możesz także usunąć pliki proxy, klikając przycisk , co spowoduje usunięcie wybranego pliku proxy.
  Po dodaniu plików proxy zostaną one skopiowane do folderu Extensions twojego projektu (możesz je znaleźć, klikając prawym przyciskiem myszy  na stronie extension i wybierając opcję Otwórz w Eksploratorze), więc jeśli musisz je edytować, powinieneś edytować skopiowane pliki dołączone do gry, a nie zaimportowany plik źródłowy, ponieważ GameMaker Studio 2 będzie używał do kompilacji plików znajdujących się w projekcie.
  Konwencje nazewnictwa
  Bardzo ważne jest, aby pliki proxy były zgodne z poniższymi konwencjami nazewniczymi, ponieważ GameMaker Studio 2 przetworzy te nazwy i przypisze moduł docelowy dla pliku zgodnie z jego adresem extension i nazwą, a następnie automatycznie połączy pliki za Ciebie. Jeśli nie zastosujesz się do tych konwencji, Twoja gra może nie działać na stronie runtime, ponieważ GameMaker Studio 2 nie będzie w stanie określić, którego pliku użyć, więc nie załaduje go poprawnie.
  Poniżej podano konwencje nazewnictwa dla każdej platformy docelowej:
  
    
      
      
    
    
      
        Platforma
        Nazwy
      
      
        Windows 32bit Runtime
        <Name>.dll, lib<Name>.dll
      
      
        Windows 64bit Runtime
        <Name>_x64.dll, lib<Name>_x64.dll
      
      
        UWP
        <Name>.dll, <Name>_win8_x86.dll, <Name>_win8_arm.dll, lib<Name>_win8_x86.dll, lib<Name>_win8_arm.dll
      
      
        Ubuntu (Linux)
        <Name>.so, lib<Name>.so,
            <Name>_linux.so, lib<Name>_linux.so,
            
            <Name>_arm.so, lib<Name>_arm.so,
            lib<Name>_linux_arm.so,
            
            <Nazwa>_arm64.so, lib<Nazwa>_arm64.so, lib<Nazwa>_linux_arm64.so,
            
            <Nazwa>_arm64-v8.so,
           lib<Nazwa>_arm64-v8.so, lib<Nazwa>_linux_arm64-v8.so,
            
            <Name>_armeabi-v7a.so, lib<Name>_armeabi-v7a.so, lib<Name>_linux_armeabi-v7a.so
      
      
        macOS
        <Name>.dylib, lib<Name>.dylib
      
      
        HTML5
        <Name>.js
      
      
        PS4
        <Name>.prx, lib<Name>.prx, <Name>_ps4.prx, lib<Name>_ps4.prx
      
      
        PS5
        <Name>.prx, lib<Name>.prx, <Name>_ps5.prx, lib<Name>_ps5.prx
      
      
        Xbox One
        <Name>.dll, <Nazwa>_xboxone.dll
      
      
        Xbox Seria X|S
        <Name>.dll, <Nazwa>_xboxseriesxs.dll
      
    
  
  Korzystając z powyższej konwencji, należy zamienić część <Name> na nazwę pliku podstawowego, do którego dodajemy pliki proxy.
   
   
  
    
      
        Powrót: Redaktor Extension 
        Następny: Rozszerzenia systemu Android
      
    
    © Copyright YoYo Games Ltd. 2022 Wszystkie prawa zastrzeżone.
  
  
  

