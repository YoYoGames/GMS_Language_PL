
    Wydarzenia dotyczące obiektów
    Czym więc są wydarzenia object? Zasadniczo są to dyskretne momenty w grze loop, w których rzeczy dzieją się zgodnie z tym, co dla nich zaprogramowałeś. GameMaker pracuje z cyklami takich zdarzeń - od momentu uruchomienia room do jego zakończenia toczy się gra loop, w której co krok uruchamiana lub sprawdzana jest seria zdarzeń, a Ty możesz umieścić w swojej GML kod lub objects wizualne akcje, które reagują na te zdarzenia (krok to moment w czasie gry, regulowany przez ustawienia room speed, może być też nazywany klatką).
    Przyjrzyjmy się typowej konfiguracji strony object z uwzględnieniem zdarzeń i kodu:
    Jak widać na naszym przykładzie object, na liście znajduje się wiele zdarzeń, na które powinna ona reagować, ale początkowo, gdy tworzysz stronę object, lista ta jest pusta i musisz zdecydować, które zdarzenia są potrzebne i co instancje tej strony object powinny zrobić, gdy te zdarzenia zostaną wywołane. Aby dodać zdarzenia do object, należy nacisnąć przycisk Dodaj zdarzenie znajdujący się na dole listy zdarzeń, co spowoduje wyświetlenie następującego okna:
    Jest to lista wszystkich podstawowych zdarzeń i kategorii zdarzeń, na które może reagować object, a w ramach każdej kategorii znajdują się zdarzenia podrzędne, które umożliwiają dalsze doprecyzowanie zachowań. Na przykład, jeśli klikniesz kategorię zdarzeńNaciśnięcie klawisza , pojawi się kolejne okno ze zdarzeniami, które pozwalają wybrać, na który klawisz ma reagować object.
    Po wybraniu zdarzenia zostanie do niego dołączone okno edytora zdarzeń, które zostanie otwarte po prawej stronie.
     
    Teraz można edytować kod (lub bloki) GML, aby nadać witrynie object określone zachowanie lub reakcję na dane zdarzenie.
    Można kliknąć prawym przyciskiem myszy  na dowolnym zdarzeniu, które zostało dodane do strony object, aby uzyskać następujące opcje menu:
    Są to następujące opcje:
    
      Dodaj wydarzenie - dodawanie nowego wydarzenia z listy wydarzeń.
      Wytnij/  Kopiuj /  Wklej zdarzenia - Wytnij, skopiuj lub wklej wybrane zdarzenie. Można też użyć standardowych skrótów klawiaturowych:  /  + X,  /  + C, oraz  /  + V.
      Duplikuj zdarzenie - powiela wybrane zdarzenie. Spowoduje to pobranie zawartości wybranego zdarzenia i powielenie jej w innym, określonym przez użytkownika zdarzeniu.
      Zmień wydarzenie - zmiana wydarzenia. Zostanie wyświetlony monit o wybranie innej kategorii wydarzenia, a po jej wybraniu zawartość bieżącego wydarzenia zostanie zmieniona na nowe wydarzenie (usuwając przy okazji oryginalne wydarzenie).
      Convert To GML Visual / Code - zdarzenia Object zostaną utworzone przy użyciu metody wybranej podczas tworzenia projektu, albo przy użyciu kodu, albo przy użyciu akcji GML Visual. Dzięki tej opcji można konwertować z jednej na drugą, niezależnie od typu projektu.
      Usuń zdarzenie - usuwa zdarzenie (lub zdarzenia).
    
    Podczas usuwania zdarzeń można użyć  + , aby zaznaczyć wiele zdarzeń, a następnie usunąć je wszystkie razem. Każda utworzona strona object ma własną listę zdarzeń, które są do niej dodawane z Edytora obiektów. Zdarzenia te dzielą się na dwie kategorie:
    
      te, które uruchamiają każdy krok gry
      te, które są "wyzwalane" przez zdarzenie w grze, takie jak osiągnięcie przez instancję krawędzi room lub naciśnięcie klawiatury albo myszy.
    
    Pełna lista wydarzeń znajduje się poniżej:
    Utwórz stronę
    
      To zdarzenie ma miejsce, gdy po raz pierwszy tworzona jest instancja object, i jest pierwszą rzeczą, która dzieje się w instancji umieszczonej w room za pośrednictwem edytora Room po wejściu na stronę room. Oznacza to, że to zdarzenie jest idealnym miejscem do inicjalizacji zmiennych, uruchamiania linii czasowych, ustawiania ścieżek itp. oraz wykonywania wszelkich innych czynności, które zazwyczaj muszą być wykonane tylko raz lub tylko podczas pierwszego tworzenia instancji w room. Jeśli na stronie object dodano zmienne obiektu lub zmienne instancji w Edytorze Object lub Edytorze Room, zmienne te zostaną najpierw zainicjowane, a następnie zostanie uruchomione zdarzenie Create Event.
      Pamiętaj, że wszystko, co zostało ustawione w zdarzeniu tworzenia, możesz modyfikować w kodzie tworzenia instancji w edytorze Room, ponieważ jest on uruchamiany bezpośrednio po zdarzeniu tworzenia instancji i może być użyty do tworzenia zmiennych instancji lub zastępowania zmiennych dodanych jako zmienne Object lub w samym zdarzeniu tworzenia.
       
       
    
    Zniszcz
    
      To zdarzenie jest zdarzeniem, które zostanie wykonane, gdy instancja zostanie zniszczona. Często jest ono pomijane przy dodawaniu zachowań do objects, ale może być bardzo użyteczne, na przykład przy tworzeniu efektów eksplozji lub cząsteczek po zabiciu wroga, lub przy ponownym uruchomieniu nowej instancji object w innej części room, a nawet przy dodawaniu punktów do wyniku.
       
    
    Sprzątanie
    
      To zdarzenie zostanie wywołane po każdym zdarzeniu, które spowoduje usunięcie instancji object z witryny room. Zostanie więc wywołane, jeśli:
      
        instancja zostanie zniszczona
         room kończy się
        gra się kończy
      
      Jest on przeznaczony do "czyszczenia" wszelkich zasobów dynamicznych, które możesz mieć w swojej grze (takich jak powierzchnie, struktury danych itp.), lub do wykonywania dowolnych zadań, które musisz wykonać raz , gdy instancja zostanie w jakikolwiek sposób usunięta z gry.
      Zauważ, że to zdarzenie zostanie wywołane natychmiast po zdarzeniu, które je wywołało, ale instancja nie zostanie faktycznie usunięta z gry aż do zakończenia bieżącego zdarzenia. Na przykład, jeśli wywołasz instance_destroy() w zdarzeniu Step, zostanie wywołane zdarzenie Destroy, następnie zdarzenie Clean Up, a po nim zakończy się reszta zdarzenia Step Event. Oznacza to, że każdy kod, który zostanie wykonany po wywołaniu instance_destroy(), będzie nadal wykonywany i może być przyczyną błędów, jeśli wyczyszczono strukturę danych lub inny zasób wymagany przez ten kod, dlatego należy zachować ostrożność podczas korzystania z tego zdarzenia. 
       
    
    Alarm
    
      Kategoria alarmów jest podzielona na 12 zdarzeń, po jednym dla każdego z możliwych alarmów, które można ustawić w danej instancji. Tak więc po kliknięciu kategorii Dodaj alarm pojawi się to okno:
      W tym miejscu wybierasz alarm, który chcesz utworzyć, a po jego utworzeniu zobaczysz, że został on dodany do okna zdarzeń, dzięki czemu możesz normalnie dodawać do niego kod. Ale co to jest alarm? Jest to specjalne zdarzenie, które nic nie robi, chyba że alarm został wcześniej ustawiony, a następnie czeka, aż alarm odliczy do 0, zanim zostaną uruchomione działania lub kod, które zostały do niego dodane.
      Gdy alarm osiągnie wartość 0 i uruchomi kod, będzie odliczał do -1, gdzie pozostanie aż do ponownego ustawienia (co oznacza, że możesz sprawdzić, czy wartość alarmu jest większa niż -1, co powie Ci, czy jest on uruchomiony, czy nie). Tak więc, jeśli w zdarzeniu create object ustawisz wartość alarm[0] na 30, oznacza to, że GameMaker będzie odliczał 30 kroków gry, zanim wykona akcje lub kod umieszczony w zdarzeniu alarm[0]. Zauważ, że ustawienie alarmu na 0 nie spowoduje uruchomienia kodu alarmu, ponieważ zdarzenie zostanie wywołane, ale alarm zostanie natychmiast ustawiony na -1, więc kod zostanie pominięty. Jeśli alarm ma być uruchamiany w następnym kroku, należy ustawić go na 1.
      Może to być bardzo użyteczne, ponieważ umożliwia wprawianie przedmiotów w ruch w ściśle określonych momentach, a nawet ich powtarzanie, ponieważ nic nie stoi na przeszkodzie, aby ustawić alarm w jego własnym zdarzeniu. Wyobraź sobie, że masz potwora i chcesz, aby skręcał w prawo co trzy sekundy... W zdarzeniu tworzenia ustawiasz alarm na prędkość room * 3 (jeśli prędkość room wynosi 30, to jest to 30 kroków na sekundę, więc pomnóż to przez 3 i otrzymasz 3 sekundy!), a następnie w zdarzeniu alarmu masz kod lub akcję, aby ustawić jego kierunek, a także akcję (lub kod), aby ustawić alarm na prędkość room * 3 ponownie. W ten sposób można skonfigurować prostą grę loops, w której pewne rzeczy dzieją się tylko w określonych odstępach czasu.
      Warto zauważyć, że alarm, w którym nie ma żadnych akcji ani kodu, nie będzie odliczał czasu. Jednak nawet w przypadku samego komentarza, bez kodu lub akcji, alarm będzie nadal odliczał czas i będzie można go ustawiać i sprawdzać w normalny sposób.
       
    
    Krok
    
      GameMaker dzieli czas na kroki , a prędkość room określa, ile tych kroków powinno być na sekundę (krok można też nazwać klatką). Pojedynczy krok to w zasadzie strona loop, która działa bez przerwy, a wszystkie zdarzenia są sprawdzane i wywoływane w razie potrzeby, gdy gra działa, więc jak możesz sobie wyobrazić, zdarzenie Step jest zdarzeniem, które jest sprawdzane w każdym kroku gry, gdy instancja istnieje.
      Etap ten składa się z trzech etapów, które opisano poniżej:
      Do większości rzeczy wystarczy standardowe zdarzenie kroku, ale czasami chcesz mieć większą kontrolę nad tym, jaki kod jest uruchamiany i w jakim czasie, więc w tym celu masz do dyspozycji zdarzenia kroku Begin i End . Wszystkie trzy są sprawdzane co krok, ale ich kolejność nigdy się nie zmieni, nawet jeśli przyszłe aktualizacje silnika GameMakera zmienią inne zdarzenia, co oznacza, że jest to jedyna niezawodna metoda upewnienia się, że coś zawsze dzieje się przed czymś innym.
      Do czego można wykorzystać zdarzenie step? Cóż, można je wykorzystać do działań lub kodu, który musi być wykonywany w sposób ciągły. Na przykład, jeśli jedna strona object ma podążać za drugą, można tu dostosować kierunek ruchu w stronę strony object, za którą podążamy, aby ta poruszała się płynnie za nami. Należy jednak uważać z tym zdarzeniem i nie umieszczać wielu skomplikowanych akcji w zdarzeniu step w objects, zwłaszcza jeśli planujesz mieć wiele instancji object w swojej grze room, ponieważ może to spowolnić grę. Wiele rzeczy można umieszczać w alarmach lub ustawiać ich wyzwalanie za pomocą innych zdarzeń, zamiast wykonywać je przez cały czas.
       
       
    
    Kolizja
    
      Oczywiście podczas tworzenia gry bardzo ważne jest, aby wiedzieć, kiedy dwie (lub więcej) instancje object zderzą się ze sobą, a do tego celu służy zdarzenie kolizji. Jest to zdarzenie, które umieszcza się w witrynie object, a następnie określa, w stosunku do których innych witryn object należy sprawdzać kolizje.
      Jeśli nie masz włączonej fizyki, kolizje te będą obliczane na podstawie maski obu objects (maska jest zdefiniowana we właściwościach sprite lub może być przypisana niezależnie we właściwościach object ) oraz tego, czy się pokrywają, czy nie. Zauważ, że jeśli jedna lub druga instancja w kolizji nie ma przypisanej maski (lub maska sprite jest ustawiona na zero), to nawet jeśli coś rysuje, nie zostaną wykryte żadne kolizje.
      Jeśli masz włączoną fizykę , wtedy kolizja będzie oparta na typie kształtu kolizji(Fixture), który zdefiniowałeś dla object w jego właściwościach fizyki, podobnie jak jego reakcja na kolizję. Oznacza to, że możesz nie potrzebować żadnego kodu do obsługi kolizji, ale zdarzenie to będzie musiało zawierać co najmniej komentarz , aby kolizje zostały wykryte.
      Na koniec należy zauważyć, że wszystkie kolizje będą obliczane raz na krok gry, zanim zostanie wywołane zdarzenie kolizji, tak więc gdy zdarzenie kolizji zostanie uruchomione, wszystkie kolizje zostaną już obliczone i wstępnie przypisane. Oznacza to, że jeśli utworzysz instancję w tym zdarzeniu, a następnie spróbujesz sprawdzić, czy doszło do kolizji, kolizja nie zostanie wykryta ani rozwiązana aż do następnej iteracji gry loop.
       
       
    
    Klawiatura,  Prasa do klawiatury,   Odblokowanie klawiatury
    
      Umożliwienie graczowi kontrolowania różnych aspektów gry jest bardzo ważne. W tym celu GameMaker udostępnia bardzo obszerną listę zdarzeń klawiaturowych, które można wykorzystać w każdej z trzech głównych kategorii klawiatur. W przypadku kategorii Klawiatura ogólna, jest ona wyzwalana w sposób ciągły co krok, dopóki wybrany klawisz jest wciśnięty, natomiast zdarzenia z kategorii Naciśnięcie i zwolnienie będą wyzwalane tylko raz, gdy klawisz zostanie wciśnięty lub zwolniony.
      Należy zauważyć, że zdarzenia klawiaturowe są wyzwalane we wszystkich aktywnych instancjach w witrynie room za każdym razem, gdy zostanie użyty klawisz, ale zareagują tylko te, które mają zdefiniowane zdarzenie dla danego klawisza. Można utworzyć wiele zdarzeń klawiaturowych w dowolnej witrynie object, a instancje tej witryny object zareagują na nie wszystkie podczas gry.
      Po dodaniu dowolnego zdarzenia klawiaturowego do witryny object zostanie wyświetlone menu zdarzeń podrzędnych klawiatury, w którym można określić klawisz, który ma być sprawdzany:
      Większość z nich jest dość oczywista, ale omówmy pokrótce poszczególne sekcje - na górze mamy klawisze strzałek, następnie najczęściej używane klawisze modyfikatorów, potem resztę klawiatury (podzieloną na dalsze podsekcje, aby można było uzyskać dokładny wymagany klawisz, np.  lub ), a na końcu dwa bardzo specjalne zdarzenia podrzędne, No Key i Any Key. Jak sugerują ich nazwy, są to zdarzenia podrzędne, które sprawdzają, czy nie został naciśnięty żaden klawisz lub czy został naciśnięty dowolny klawisz. Należy pamiętać, że klawisze klawiatury numerycznej wywołują odpowiednie zdarzenia tylko wtedy, gdy włączona jest funkcja Number Lock .
      Zdarzenia Naciśnięcie i Zwolnienie klawisza są prawie dokładnie takie same jak zwykłe zdarzenia klawiatury, z tą różnicą, że zamiast być wyzwalane w sposób ciągły, są wyzwalane tylko raz. Gdy klawiatura po raz pierwszy zarejestruje, że klawisz został naciśnięty, wygeneruje zdarzenie Naciśnięcie klawisza (oraz zwykłe zdarzenie Klawiatura), a za pierwszym razem, gdy klawisz nie będzie już wykrywany jako naciśnięty, wygeneruje pojedyncze zdarzenie Zwolnienie klawisza.
       
       
    
    Mysz
    
      Kategoria Mysz jest podzielona na serię zdarzeń, które można wybrać, aby uzyskać bardziej precyzyjną kontrolę nad tym, co dzieje się w grze. Tutaj można zobaczyć, jakie dokładnie są to zdarzenia:
      Zdarzenia związane z lewym , prawym  i środkowym  przyciskiem ( normalne, wciśnięte lub zwolnione) działają na maskę instancji, która ma zdarzenie. Oznacza to, że GameMaker sprawdzi pozycję myszy w witrynie room, gdy zostaną użyte te przyciski, względem masek kolizji instancji, które mają zdarzenie myszy. Jeśli dojdzie do "kolizji" z bounding boxem instancji, zdarzenie zostanie wywołane, więc upewnij się, że każda instancja z tymi zdarzeniami ma sprite z poprawną maską kolizji lub że object ma maskę sprite wybraną we właściwościach object. Jak sugerują ich nazwy, zdarzenia te będą wyzwalane albo jednorazowo, gdy wybrany przycisk myszy zostanie po raz pierwszy naciśnięty lub zwolniony, albo w sposób ciągły w każdym kroku, gdy przycisk jest przytrzymywany. 
      Zdarzenia wejścia i wyjścia myszy są również podobne do zdarzeń przycisków, ponieważ ich działanie również opiera się na masce instancji, ale tym razem są one wyzwalane, gdy mysz po raz pierwszy "wejdzie" (dotknie) instancji lub gdy "wyjdzie" (przestanie dotykać) instancji. Zdarzenia te nie są jednak ciągłe i są wyzwalane tylko raz za każdym razem, gdy mysz wejdzie lub opuści instancję object - są więc idealną metodą tworzenia np. przycisków, które mają się zmieniać po najechaniu na nie myszą, a następnie wracać do normalnego stanu po usunięciu myszy.
      Na koniec mamy jeszcze jedną sekcję zdarzeń myszy, która nosi nazwę Mysz globalna. W tym podmenu znajdziesz wybór zdarzeń, które służą do rejestrowania zdarzeń myszy w instancjach, nawet jeśli mysz nie znajduje się nad nimi lub nawet w ich pobliżu. Są to zdarzenia, które są generowane dla wszystkich instancji i jeśli dla danego zdarzenia są zdefiniowane akcje lub kod, to zostaną one uruchomione, niezależnie od położenia myszy w grze room.
      Należy pamiętać, że w urządzeniach przenośnych lub z ekranem dotykowym lewy przycisk myszy  może być również używany do sprawdzania, czy na ekranie dotykowym nie ma tabulatora z palcem, a prawy przycisk myszy  jest wyzwalany przez podwójne stuknięcie w ekran (to zachowanie można zmienić za pomocą kodu).
       
       
    
    Gesty
    
      Jest to zdarzenie, które zostanie wywołane przez użytkownika dotykającego ekranu (na urządzeniach mobilnych) lub klikającego i poruszającego myszą (na wszystkich innych platformach). Zdarzenia te są podobne do zdarzeń myszy, ponieważ istnieją wersje zwykłe oraz wersje globalne. Zwykłe wersje tych zdarzeń są wyzwalane tylko wtedy, gdy dotknięcie nastąpi na instancji, która ma stronę sprite (lub maskę), a dotknięcie nastąpi w jej polu ograniczającym. Natomiast globalne wersje tych zdarzeń zostaną wywołane przez użytkownika dotykającego dowolnego miejsca na ekranie.
      Zdarzenia związane z gestami pozwalają wykryć następujące elementy:
      
         stuknięcia -  gdy użytkownik klika/dotyka i szybko zwalnia przycisk
         przeciąganie -  gdy użytkownik dotknie/kliknie i przytrzyma, a następnie przesunie palec/kursor
         kliknięcia -  gdy użytkownik przesuwa i zwalnia dotyk/kliknięcie jednym ruchem
         uszczypnięcia -  gdy użytkownik trzyma dwa palce na ekranie, a następnie przesuwa je razem/oddziela od siebie
         obraca -  gdy użytkownik trzyma dwa palce na ekranie, a następnie obraca je wokół punktu
      
      Różne zdarzenia będą zawsze zawierać mapę DS o nazwie "event_data", która będzie zawierać pewną liczbę par klucz/wartość z danymi dotyczącymi pozycji i ruchu dotknięcia/kliknięcia. Szczegółowe informacje o wszystkich dostępnych zdarzeniach podrzędnych i sposobie ich działania można znaleźć w następującej sekcji:
      
        Wydarzenie "Gest
      
       
       
    
    Inne
    
      Istnieje wiele specjalnych zdarzeń, z których można korzystać podczas tworzenia gier w programie GameMaker. Są one w większości zgrupowane w ramach zdarzenia Other (Inne) i można je wybierać z menu podręcznego, które pojawia się po wybraniu tego zdarzenia. Poniżej znajduje się obraz wszystkich innych zdarzeń:
      Więcej informacji o każdym z wydarzeń przedstawionych na powyższej ilustracji można znaleźć w poniższej sekcji:
      
        Pozostałe wydarzenia
      
       
    
    Rysuj
    
      Ta kategoria zdarzeń decyduje o tym, co widać na ekranie po uruchomieniu gry, i jest podzielona na różne zdarzenia:
      Jak widać, kategoria zdarzeń rysowania zawiera wiele różnych typów zdarzeń. Zdarzenia Draw Begin, Draw i Draw End są "standardowymi" zdarzeniami rysowania, z których prawdopodobnie będziesz korzystać najczęściej. Domyślnie główne zdarzenie Draw jest zawsze wywoływane dla każdej instancji, niezależnie od tego, czy ma ona adres sprite, czy nie, choć jeśli flag instancja jest niewidoczna, zdarzenie to nie zostanie wywołane (pamiętaj o tym, jeśli masz jakąś logikę gry w zdarzeniu draw niewidocznego obiektu object, ponieważ nie zostanie ona uruchomiona). Zdarzenie main draw jest także tym, w którym GameMaker domyślnie rysuje instancję sprite, jeśli w zdarzeniu nie ma żadnego kodu ani akcji (tzn. nie dodałeś go do listy zdarzeń dla object). Domyślne rysowanie używa adresu sprite powiązanego z instancją i będzie ją rysować z wszelkimi transformacjami ustawionymi w kodzie lub zastosowanymi akcjami.
      Standardowe zdarzenia rysowania są rysowane przed zdarzeniami Rysuj GUI i między zdarzeniami Przed rysowaniem i Po rysowaniu, co oznacza, że wszystko, co zostanie narysowane w tym zdarzeniu, jest rysowane pod zdarzeniem Rysuj GUI , niezależnie od warstwy (tzn. wszystko, co zostanie narysowane w zdarzeniu Rysuj GUI, będzie zawsze rysowane nad wszystkim, co zostanie narysowane w zwykłym zdarzeniu rysowania, niezależnie od kolejności warstw).
      Powyżej przedstawiono ogólny zarys działania zdarzeń losowania, natomiast szczegółowe informacje na temat wszystkich dostępnych zdarzeń podrzędnych można znaleźć w następującej sekcji:
      
        Wydarzenie losowania
      
       
       
       
    
    Asynchroniczne
    
      Ta kategoria zdarzeń jest szczególna, ponieważ zdarzenia w niej zawarte nie są domyślnie wywoływane przez program GameMaker, ale raczej przez zakończenie jakiejś innej akcji, na przykład załadowanie pliku lub odpowiedź z witryny server. Kategoria ta jest podzielona na następujące zdarzenia:
      
      Powiedzmy, że chcesz dodać plik graficzny do programu GameMaker. Cóż, zakodowałbyś to w innym zdarzeniu (być może w zdarzeniu Create Event) na stronie object, a następnie kazałbyś tej stronie object narysować pasek ładowania podczas oczekiwania (na przykład), wywołując odpowiednie zdarzenie asynchroniczne aż do wywołania zwrotnego, które powie GameMakerowi, że plik został załadowany. Dane zwrócone w tym zdarzeniu można następnie wykorzystać do innych celów, np. zmiany adresu room lub zakupu przedmiotu.
      Powyżej przedstawiono ogólny zarys działania zdarzenia asynchronicznego, natomiast szczegółowe informacje na temat wszystkich dostępnych zdarzeń podrzędnych można znaleźć w następującej sekcji:
      
        Lista zdarzeń asynchronicznych
      
       
    
     
    Należy również pamiętać, że zdarzenia można nazywać, a przynajmniej nadawać im krótki tekst opisowy, który będzie wyświetlany obok nich w Edytorze zdarzeń. Aby to zrobić, wystarczy w pierwszym wierszu edytora kodu zdarzenia (jeśli używasz kodu GML) dodać poniższy tekst:
    /// @description Your text here
    Coś takiego może się znaleźć na przykład w zdarzeniu Alarm :
    /// @description This is the AI Fight alarm
    Teraz w Edytorze zdarzeń zobaczysz to:
    
    Dla użytkowników GML Visual dodanie komentarza wymaga użycia akcji Execute Code, którą należy umieścić na samej górze listy akcji dla danego zdarzenia, przed wszystkimi innymi. Po dodaniu tej akcji należy nadać jej tę samą linię kodu, która została pokazana powyżej, aby nazwać zdarzenie, np:
    Dodatkowe informacje na temat niektórych z powyższych imprez oraz ogólny porządek przebiegu imprezy można znaleźć w poniższych sekcjach:
    
      Kolejność zdarzeń
      Pozostałe wydarzenia
      Wydarzenia związane z losowaniem
      Zdarzenia asynchroniczne
      Wydarzenia związane z gestami
    
     
     
     
    
      
        
          Powrót: Redaktor Object 
          Następny: Obiekty macierzyste
        
      
      © Copyright YoYo Games Ltd. 2022 Wszystkie prawa zastrzeżone.
    
    
