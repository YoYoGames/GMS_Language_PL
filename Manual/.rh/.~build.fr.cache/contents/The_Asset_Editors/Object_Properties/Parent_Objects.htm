
  
  Obiekty macierzyste
  Podczas pracy z objects w programie GameMaker IDE można tworzyć hierarchie rodzic /  dziecko. Robi się to klikając przycisk "Parent" w edytorze object, a następnie wybierając inną stronę object z przeglądarki Asset Browser
    który ma być "rodzicem" edytowanego pliku:
  Tak więc każda strona object w projekcie gry może mieć rodzica object, ale co to oznacza? Cóż, gdy object ma przypisanego rodzica, może
    współdzielić kod, akcje i zdarzenia z rodzicem. To współdzielenie jest nazywane "dziedziczeniem", a object, który ma rodzica, jest nazywany "dzieckiem" object. Dziecko nie tylko może współdzielić kod ze swoim rodzicem, ale można też sprawdzać i uruchamiać kod
    na rodzica objects i automatycznie uwzględni on również dziecko objects, co pozwala zaoszczędzić wiele czasu i energii.
  Jeśli brzmi to skomplikowanie, to innym sposobem spojrzenia na stronę object jest sposób na "zgrupowanie" objects pod jednym parasolem i umożliwienie im dzielenia pewnych rzeczy bez utraty własnej, niepowtarzalnej tożsamości. Może to nadal nie
    nie wyjaśnia zbyt wiele, więc podajmy kilka przykładów...
  Załóżmy, że masz "gracza" object i czterech różnych "wrogów" objects. Teraz chcesz, aby gracz zginął, jeśli dotknie któregoś z tych czterech objects. W normalnych warunkach wymagałoby to czterech różnych zdarzeń kolizji z czterema różnymi zestawami
    działań lub kodu, po jednym dla każdego z wrogów objects. ALE jeśli dla wszystkich wrogów utworzymy nadrzędny object, możemy utworzyć jedno zdarzenie kolizji tylko z nadrzędnym object i będzie ono wywoływane niezależnie od tego, które z czterech "dzieci" wroga
    objects dotknie gracza. Przydatna rzecz! W rzeczywistym programie GameMaker object zobaczyłbyś coś takiego:
  Po lewej stronie mamy cztery osobne zdarzenia kolizji, a po prawej jedno zdarzenie kolizji, ponieważ utworzyliśmy
    "rodzica" object i przypisaliśmy do niego wszystkie wrogie objects. Zauważ, że strona nadrzędna object nie musi mieć żadnych zdarzeń ani kodu...
  Innym przykładem parentingu może być gra, w której chcesz stworzyć 10 różnie wyglądających stron objects i sprawić, by wszystkie zachowywały się w ten sam sposób. W tym celu należałoby utworzyć jedną stronę nadrzędną object i w niej umieścić wszystkie akcje związane z zachowaniem lub kod
    w wymaganych zdarzeniach, a następnie utworzysz dziesięć objects bez żadnych akcji ani kodu, ale z różnymi sprites, i przypiszesz im swojego rodzica object. Teraz, gdy umieścisz te instancje w witrynie room, wszystkie będą zachowywać się tak samo, ale będą wyglądać inaczej,
    ponieważ "odziedziczą" zdarzenia po rodzicu.
  Wreszcie, można używać funkcji rodzicielskich do "mieszania i dopasowywania" zdarzeń i zachowań. Zilustrujemy to na ostatnim przykładzie... Powiedzmy, że chcemy mieć dwa potwory: jeden porusza się w górę i w dół, a drugi w lewo i w prawo.
    aby oba potwory miały takie samo zdrowie, strzelały do gracza i zadawały mu obrażenia, jeśli się z nimi zderzy. W tym przypadku widać, że prawie wszystkie zdarzenia powinny mieć takie same akcje, z wyjątkiem jednego lub dwóch, które regulują ruch. Ponownie możemy więc sprawić, że
    jeden object rodzicem drugiego, ale w tym przypadku definiujemy także pewne zdarzenia dla dziecka object. Te zdarzenia "nadpisują" zdarzenia rodzica, co oznacza, że gdy zdarzenie dla dziecka object zawiera akcje, są one wykonywane
    zamiast akcji zawartych w zdarzeniu rodzica. Jeśli chcesz także wykonać zdarzenie rodzica, możesz wywołać tak zwane zdarzenie "dziedziczone", używając funkcji event_inherited(),
    lub akcji wizualnej GML Visual Call Parent Event.
  Po lewej stronie znajduje się strona nadrzędna object z 5 zdarzeniami, a po prawej stronie - "dziecko" object. Obiekt dziecka
    również ma 5 zdarzeń, ale dwa z nich zastępują zdarzenia odziedziczone po rodzicu (zdarzenia Krok i Rysuj ), a pozostałe trzy są wyszarzone, ponieważ są to zdarzenia odziedziczone po rodzicu. Zdarzenia dziedziczone
    będą miały również ikonę "nadpisania przez rodzica" w edytorze zdarzeń:
  Po kliknięciu na stronie  zdarzenia, które zostało odziedziczone,
    otworzy się edytor kodu, aby wyświetlić odziedziczony kod rodzica, ale nie będzie można edytować tego kodu, ponieważ można go edytować tylko w samym rodzicu object. Kliknięcie prawym przyciskiem myszy  na dowolnym zdarzeniu nadrzędnym spowoduje otwarcie następującego menu opcji:
  W tym miejscu można wybrać dwie opcje Otwórz zdarzenie nadrzędne, aby sprawdzić kod, lub można wybrać opcję Dziedziczenie zdarzenia
    lub Zastąpić zdarzenie. Jeśli wybierzesz opcję Dziedziczenie , edytor kodu zostanie otwarty z funkcją event_inherited() już
    (lub akcją Call Parent Event, jeśli używasz GML Visual). Każdy kolejny kod umieszczony w tym zdarzeniu zostanie uruchomiony tak samo, jak kod obiektu nadrzędnego
    ma. Jeśli wybierzesz opcję Zastąp zdarzenie, okno z kodem również zostanie otwarte, ale teraz funkcja event_inherited() nie zostanie wywołana, więc wszystko, co dodasz w tym miejscu, zostanie uruchomione zamiast kodu
    w obiekcie nadrzędnym object.
  UWAGA: W edytorze kodu można szybko przejść do strony nadrzędnej object, klikając prawym przyciskiem myszy  i wybierając z menu podręcznego polecenie Przejdź do obiektu, lub (jeśli zdarzenie zostało nadpisane) można wybrać polecenie Otwórz zdarzenie dziedziczone, aby przejść bezpośrednio do edytora kodu z kodem zdarzenia nadrzędnego.
  Zawsze, gdy w kodzie jest mowa o instancjach rodzica object, kod ten zostanie zastosowany także do "dzieci" rodzica object. Dzieje się tak, gdy w akcji wskażesz, że akcja musi być zastosowana do instancji określonego obiektu object, a w kodzie
    dzieje się to, gdy używasz with() oświadczenia. Tak samo będzie to działać, gdy wywołasz w kodzie funkcje, takie jak instance_position(),
    instance_number(), itp... gdzie - jeśli podasz adres nadrzędny object - wszystkie instancje rodzica i dziecka
    zostaną uwzględnione w sprawdzeniach. Wreszcie, parenting działa także w przypadku odwoływania się do zmiennych w innych witrynach objects, np. w powyższym przykładzie potwora, jeśli ustawię prędkość wroga 1 na 10, to prędkość wroga 2 również wyniesie 10, ponieważ jest on dzieckiem object wroga
    1.
   object W większości przypadków za dobrą praktykę uważa się tworzenie jednego rodzica object i umieszczanie w nim wszystkich domyślnych zachowań, ale nigdy nieużywanie jego instancji w grze. Należy raczej używać wszystkich dzieci objects i korzystać z rodzica tylko w
    w sytuacjach takich jak te, które opisałem powyżej, w przypadku kolizji, odwołań do zmiennych itp. Powinieneś także zdawać sobie sprawę, że rodzice mogą mieć rodziców! Oczywiście nie można utworzyć cyklu "rodzic 1 jest dzieckiem rodzica 2 jest dzieckiem rodzica
    1", ale możesz stworzyć tak zwaną "hierarchię obiektów", gdzie "rodzic3 jest dzieckiem rodzica2 jest dzieckiem rodzica1". Jest to niezwykle użyteczne, aby zachować strukturę gry i zdecydowanie zaleca się
    nauczenie się korzystania z tego mechanizmu.
   
   
   
  
    
      
        Powrót: Redaktor Object 
        Następny: Obiekty fizyki
      
    
    © Copyright YoYo Games Ltd. 2021 Wszystkie prawa zastrzeżone.
  
  
  

