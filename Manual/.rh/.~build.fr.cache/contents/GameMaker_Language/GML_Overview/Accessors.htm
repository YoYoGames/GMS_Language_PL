
  
  Akcesoria
  Strona GameMaker Language (GML) pozwala także na dostęp do pewnych struktur danych i tablic za pomocą wyrażeń logicznych zwanych accessorami. Struktura jest podobna do normalnej pracy z tablicą, z tą różnicą, że używamy symbolu identyfikatora przed pierwszym argumentem, aby poinformować GameMakera, że pracujemy nad (wcześniej utworzoną) strukturą danych lub literałem tablicy.
   
  Listy DS [| ]
  
    Składnia list DS jest następująca:
    list_index[| index]
    Tak więc po utworzeniu listy za pomocą strony ds_list_create() należy użyć indeksu listy (przechowywanego w zmiennej), aby się do niej odwołać, przy czym wartość "index" oznacza pozycję na liście, którą należy ustawić lub dodać. Na przykład poniższy kod tworzy listę, a następnie dodaje 10 wpisów, ustawiając każdy z nich na losową liczbę od 0 do 9:
    ds = ds_list_create();
      var index = 0;
      repeat(10)
      {
          ds[| index++] = irandom(9);
      }
    Zwróć uwagę, że jeśli używasz wyrażenia do dodania odwołania do indeksu, który ma już wartość, poprzednia wartość zostanie zastąpiona, a nie dodany zostanie kolejny indeks do listy. Aby dodać kolejne wpisy, należałoby znać rozmiar listy ds_list i dodać je na końcu. Warto również zauważyć, że można ustawić indeks listy większy niż rozmiar listy, do której się odwołujemy, a to spowoduje ustawienie tej wartości, jednocześnie rozwijając listę i inicjalizując wszystkie pozycje na liście do podanego indeksu jako 0.
    Po utworzeniu struktury listy i wypełnieniu jej danymi, aby pobrać wartości z listy, należy wykonać następujące czynności:
    value = ds[| 5];
    Powyższe polecenie pobierze wartość z pozycji 5 (szósty indeks, ponieważ listy zaczynają się od 0) i zapisze ją w zmiennej. Jeśli podasz pozycję spoza rozmiaru listy, to zwrócona zostanie wartość undefined, którą możesz sprawdzić za pomocą funkcji is_undefined().
     
  
  Mapy DS [? ]
  
    Składnia map DS jest następująca:
    map_index[? key]
    Po utworzeniu mapy za pomocą ds_map_create(), w celu odwołania się do niej należy użyć indeksu mapy zapisanego w zmiennej, przy czym wartość "key" oznacza klucz mapy, który należy ustawić lub uzyskać. Na przykład poniższy kod tworzy mapę, a następnie dodaje do niej kilka wpisów, używając tej składni:
    ds = ds_map_create();
      ds[? "Name"] = "Hamish";
      ds[? "Company"] = "MacSeweeny Games";
      ds[? "Game"] = "Catch The Haggis";
    Należy zauważyć, że jeśli mapa zawiera już tę samą wartość klucza, którą próbujemy dodać, nie zostanie utworzony duplikat klucza z nową wartością, lecz poprzednia wartość zostanie zastąpiona.
    Po utworzeniu struktury mapy i wypełnieniu jej danymi, aby uzyskać wartości z określonego klucza mapy, należy wykonać coś takiego:
    value = ds[? "Name"];
    Powyższe polecenie pobierze wartość z klucza "Nazwa" i zapisze ją w zmiennej, ale należy pamiętać, że jeśli podany klucz nie istnieje w mapie DS, to zwrócona wartość będzie miała postać undefined. Można to sprawdzić za pomocą funkcji is_undefined().
     
  
  DS Grids [# ]
  
    Składnia dla siatki DS jest następująca:
    grid_index[# xpos, ypos]
    Po utworzeniu siatki za pomocą funkcji ds_grid_create() należy użyć indeksu siatki przechowywanego w zmiennej, aby się do niej odwołać, przy czym "xpos" i "ypos" oznaczają pozycję w siatce w celu uzyskania lub ustawienia wartości. Na przykład w poniższym kodzie utworzono siatkę, wyczyszczono ją do wartości 0, a następnie dodano do niej kilka wpisów:
    ds = ds_grid_create();
      ds_grid_clear(ds, 0);
      var gw = ds_grid_width(ds) - 1;
      var gh = ds_grid_height(ds) - 1;
      repeat(10)
      {
          var xx = irandom(gw);
          var yy = irandom(gh);
          if (ds[# xx, yy] == 0)
          {
              ds[# xx, yy] = 1;
          }
      }
    Po utworzeniu struktury siatki i wypełnieniu jej danymi, aby uzyskać wartości z określonej pozycji siatki, należy wykonać następujące czynności:
    value = ds[# mouse_x div 16, mouse_y div 16];
    Powyższe działanie spowoduje pobranie wartości z podanej ds_grid na podstawie pozycji myszy (podzielonej przez szerokość "komórki" w room, aby uzyskać prawidłowe położenie). Jeśli podasz pozycję, która znajduje się poza granicami siatki, zwrócona zostanie wartość undefined, którą można sprawdzić za pomocą funkcji is_undefined().
     
  
  Tablice [@ ]
  
    Ten accessor jest używany tylko wtedy, gdy włączona jest opcja Copy on Write.
    Tablice posiadają również własne accessory, które działają w podobny sposób, jak te wymienione powyżej dla struktur danych. Jednak dostęp do tablic ma jeszcze jedną ciekawą właściwość, a mianowicie pozwala na modyfikowanie tablicy z poziomu funkcji skryptu lub method bez konieczności jej kopiowania. Gdy przekazujemy tablicę do funkcji, jest ona przekazywana przez referencję, co oznacza, że sama tablica nie jest przekazywana do script, lecz po prostu jest do niej odwoływana w celu uzyskania danych. W normalnej sytuacji, jeśli trzeba by zmienić tablicę, należałoby ją skopiować na stronę script, a następnie przekazać z powrotem (zwrócić) skopiowaną tablicę, aby oryginalna tablica została zaktualizowana. Może to powodować kosztowne koszty przetwarzania, dlatego zamiast tego można skorzystać z narzędzia dostępu, które zmieni oryginalną tablicę bezpośrednio , bez konieczności jej kopiowania. Jak to działa, można zobaczyć w poniższych przykładach.
    Składnia dla tablic, przy użyciu narzędzia dostępu @, jest następująca:
    array[@ i]
    Po utworzeniu tablicy w instancji można przekazać ją do script przez referencję i użyć akcesora @, aby ją bezpośrednio zmienić. Na przykład można utworzyć tablicę i wywołać funkcję w następujący sposób:
    array[99] = 0;
      array_populate(array);
    Sama funkcja będzie miała następującą postać:
    function array_populate(_array)
      {
          var a = _array; var i = 0; repeat(25)
          {
              i = irandom(99);
              while (a[i] != 0)
              {
                  i = irandom(99);
              }
              a[@ i] = 100;
          }
      }
    Funkcja ta wybiera 25 losowych pozycji w tablicy i ustawia wartość wybranej pozycji tablicy na 100.
    Oczywiście, gdy funkcja kopiowania przy zapisie jest wyłączona, dostęp do @ nie jest wymagany.
    UWAGA Podczas pracy z tablicą argument[n] w funkcjach skryptu nie można używać akcesora tablicy @.
     
     
  
  Struktury [$ ]
  
    Składnia struktów jest następująca
    struct[$ "name"]
    Dostęp ten jest w zasadzie opakowaniem funkcji variable_struct_get() i variable_struct_set(), z których można korzystać podobnie jak z dostępu do mapy DS. Na przykład, jeśli utworzyłeś stronę struct i chcesz pobrać wartość ze zmiennej o nazwie "my_health", wykonaj następujące czynności:
    var _hp = struct[$ "my_health"];
    Jak widać, nie podajemy samej zmiennej, ale raczej łańcuch znaków zawierający tę zmienną. Zauważ, że jeśli na stronie struct nie ma zmiennej o podanej nazwie, to accessor zwróci wartość undefined.
    Aby ustawić zmienną w witrynie struct, należy wykonać następujące czynności
    struct[$ "my_score"] = 100;
    Podobnie jak w przypadku pobierania wartości, podajesz nazwę zmiennej, którą chcesz ustawić jako string, a zostanie ona ustawiona na podaną wartość. Jeśli użyta nazwa zmiennej nie istnieje w struct, to zostanie ona utworzona i ustawiona na podaną wartość.
     
  
   
  Ważną cechą akcesorów jest to, że można je łączyć w łańcuchy. Oznacza to, że jeśli masz kilka zagnieżdżonych struktur danych i/lub tablic, nie musisz już używać wielu funkcji, aby uzyskać dostęp do wartości, która znajduje się głęboko w zagnieżdżonej strukturze. Na przykład, powiedzmy, że mamy tablicę, a każdy element w tablicy jest listą DS, jak poniżej:
  array = array_create(3);
    for (var i = 0; i < 3; ++i;)
    {
        array[i] = ds_list_create();
        switch(i)
        {
            case 0:
                with (obj_Wall) ds_list_add(array[i], id);
            break;
    
            case 1:
                with (obj_Door) ds_list_add(array[i], id);
            break;
    
            case 2:
                with (obj_Chest) ds_list_add(array[i], id);
            break;
        }
    }
  
  W powyższym kodzie utworzyliśmy tablicę składającą się z 3 elementów i przypisaliśmy każdej z nich listę DS, a następnie wypełniliśmy poszczególne listy identyfikatorami instancji różnych objects w grze. Teraz, aby uzyskać dostęp do identyfikatora na jednej z list, możemy wykonać następujące czynności:
  var _list = array[0];
    var _id = ds_list_find_value(_list, 0);
  Można jednak zrobić to samo, używając łańcuchowych accessorów, w znacznie czystszy sposób i przy użyciu mniejszej ilości kodu:
  var _id = array[0][| 0];
  W ten sposób można łączyć ze sobą wiele akcesorów i mogą one być różnych typów, aby uzyskać dostęp do informacji przechowywanych w każdej części zagnieżdżonej struktury. Oto kilka kolejnych przykładów:
  // Access a grid that has been added to a list that is part of a map:
    var _a = data[? "lists"][| 0][# 0, 0];
    
    // Access an array nested in a list from a script and modify it:
    data[| 0][@ 10] = 100;
    
    // Access a map nested in a grid nested in a list nested in an array:
    data[0][| 10][# 3, 4][? "key"] = "hello world";
  
  Używanie łańcuchowych akcesorów nie tylko oznacza, że można pisać bardziej zwarty kod, ale także pozwala na użycie iteracji (na przykład przy użyciu pętli for pętli) oraz innych technik umożliwiających dostęp do danych w czystszy i bardziej intuicyjny sposób.
  Warto zauważyć, że używając w ten sposób akcesorów, należy zawsze korzystać z akcesora @ dla tablic, ponieważ w przeciwnym razie spowoduje to dodanie dodatkowego narzutu do wykonywanych działań. Jak wspomniano powyżej, tablice są domyślnie przekazywane do funkcji przez referencję, a następnie przy modyfikacji są kopiowane przy zapisie. Jeśli jednak tablica jest częścią łańcucha, to poprzedni element łańcucha zostanie zaktualizowany skopiowaną tablicą, a "oryginał" zostanie usunięty. Na przykład, wykonując coś takiego:
  // In an object event
    data[| 0][0] = 100;
    
    // In a function
    data[| 0][0] = 200;
  
  daje takie same rezultaty jak to:
  // In an object event
    data[| 0][0] = 100;
    
    // In a function
    data[| 0][@ 0] = 200;
  
  Drugi przykład jest jednak lepszy, ponieważ działa bez zbędnego narzutu związanego z kopiowaniem całej tablicy.
   
   
   
  
    
      
        Powrót: Przegląd GML
        Następny: Cechy języka
      
    
    © Copyright YoYo Games Ltd. 2022 Wszystkie prawa zastrzeżone.
  
  
  

