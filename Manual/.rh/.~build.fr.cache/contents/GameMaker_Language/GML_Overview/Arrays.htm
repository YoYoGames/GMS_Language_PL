
  
  Tablice
  Tablice mogą być niezwykle użyteczne i są istotną częścią tworzenia gier. Jest to rodzaj zmiennej, która może przechowywać wiele wartości jako "listę" - rozważ poniższy kod:
  numbers = [ 0, 1, 2, 3, 4, 5 ];
    
    fruits = [ "Apples", "Oranges", "Mangoes" ];
  
  Używając składni [element, element, element], tworzymy tablicę , która jest przechowywana w zmiennej. Dostęp do elementów przechowywanych w tablicy można później uzyskać za pośrednictwem tej zmiennej, używając liczby całkowitej, zaczynając od 0, którą umieszcza się wewnątrz nawiasów []:
  first_fruit = fruits[ 0 ];
    second_fruit = fruits[ 1 ];
    // ...and so on.
  Podstawowa tablica ma jeden wymiar, ale można też tworzyć tablice o więcej niż jednym wymiarze. W poniższych sekcjach wyjaśniono oba typy tablic:
  Tablice jednowymiarowe
  
    Zanim przejdziemy dalej, wyjaśnijmy, czym właściwie jest tablica i jak jest zbudowana. Tablica to po prostu typ danych, który jest przypisany do zmiennej i może zawierać nie tylko jedną, ale wiele wartości. Na poniższym rysunku przedstawiono schemat podstawowej tablicy:
    
    Jest to tzw. tablica 1D (jednowymiarowa). Jak widać, tablica jest przechowywana w zmiennej "a" i zawiera wiele wartości. Aby uzyskać dostęp do tablicy, należy wykonać następujące czynności:
    var _val = a[0];
      show_debug_message(_val);
    Powyższy kod pobiera wartość z pozycji 0 tablicy "a", a następnie wypisuje ją na konsolę, co - na podstawie zawartości tablicy widocznej na powyższym rysunku - dałoby wynik 125. Gdybyś wykonał następujące czynności:
    var _val = a[3];
      show_debug_message(_val);
    Na wyjściu pojawi się napis "Cześć!".
    Jak widać, nadajemy tablicy nazwę zmiennej, a następnie wartość w nawiasach kwadratowych [], gdzie wartość jest pozycją w tablicy, z której chcemy pobrać dane. Zasadniczo więc tablica jest pojemnikiem zawierającym pewną liczbę gniazd do przechowywania wartości, a każda pozycja w pojemniku ma określony numer, który ją identyfikuje - taki właśnie numer umieszczamy na stronie []. Warto zauważyć, że zawartość tablicy zawsze zaczyna się od 0 i nigdy niemoże być ujemna!
           Tworzenie tablic
    Pokazaliśmy już, jak sprawdzać tablicę w poszukiwaniu danych, ale jak utworzyć tablicę na początek? Najpierw trzeba ją zainicjalizować, zanim będziemy mogli jej użyć, inaczej GameMaker wyśle nam błąd. Inicjalizacja tablicy oznacza po prostu, że nadajemy każdemu slotowi tablicy wartość początkową, przygotowując go do użycia w innym miejscu kodu projektu. Należy o tym pamiętać, ponieważ oznacza to, że przed użyciem tablic trzeba się nieco zastanowić, ale inicjalizacja tablicy za pomocą powtórzenia loop jest dość prosta:
    var i = 9;
      repeat(10)
      {
          array[i] = 0;
          i -= 1;
      }
    Ten prosty kod zainicjalizuje tablicę z dziesięcioma szczelinami (od 0 do 9) tak, aby zawierała 0, tzn. każda szczelina w tablicy zawiera wartość 0. Zauważysz, że tablica została zainicjalizowana od tyłu, z ostatnią wartością zdefiniowaną jako pierwsza. Nie jest to absolutnie konieczne, ale jest to optymalny sposób, ponieważ zarezerwowane zostanie miejsce w pamięci o dokładnym rozmiarze tablicy, podczas gdy inicjalizacja tablicy od 0 w górę powoduje konieczność ponownego przydzielenia pamięci dla każdej dodanej wartości (tak więc dla tablicy dziesięciogniazdowej inicjalizacja w loop spowodowałaby dziesięciokrotną zmianę przydziału pamięci). Różnica w szybkości działania jest pomijalna w przypadku mniejszych tablic, ale większe tablice powinny być w ten sposób optymalizowane na tyle, na ile to możliwe.
    UWAGA: Wyjątkiem od powyższej reguły jest eksport HTML5, w którym należy inicjalizować tablice w kolejności od 0 w górę.
    Można także użyć funkcji GML array_create() do inicjalizacji tablicy o stałym rozmiarze, a nawet można tworzyć "puste" tablice, na przykład bez wartości:
    my_array = [];
    Dzięki temu GameMaker dowie się, że zmienna "my_array" jest tablicą i można do niej dodawać wartości w dowolnym momencie w przyszłości. Jeśli jednak spróbujesz uzyskać dostęp do wartości w pustej tablicy, otrzymasz błąd.
    Jeśli wiesz już, które elementy chcesz umieścić w tablicy, możesz dodać wartości oddzielone przecinkami między nawiasami podczas deklarowania tablicy:
    my_array = ["Steve", 36, "ST-3V3 - Steve Street"];
           Granice tablic
    Należy zawsze zwracać uwagę na to, aby mieć dostęp tylko do prawidłowych pozycji w tablicy, ponieważ próba dostępu do wartości spoza tablicy również spowoduje błąd. Na przykład spowoduje to awarię projektu podczas jego uruchamiania:
    my_array = array_create(5, 0);
      var _val = my_array[6];
    Tablica została zainicjowana tylko na 5 pozycji, ale próbowaliśmy uzyskać pozycję 7 - ponieważ tablice są numerowane od 0, array[6] jest pozycją 7 - dlatego gra generuje błąd i zawiesza się.
           Używanie tablic
    Jak praktycznie używać tablicy? Dokładnie tak samo, jak w przypadku zwykłej zmiennej, jak pokazano w poniższych przykładach:
    // Add two array values together
      total = array[0] + array[5];
      
      // Check an array value
      if array[9] == 10
      {
          // Do something
      }
      
      // Draw an array value
      draw_text(32, 32, array[3]);
    
    Ponieważ tablice są numerowane sekwencyjnie, oznacza to, że możesz loop przez nie przejść, aby wykonać dodatkowe czynności, tak jak to zrobiliśmy przy inicjalizacji:
    var total = 0;
      
      for (var i = 0; i < 10; ++i)
      {
          total += array[i];
          draw_text(32, 32 + (i * 32), array[i]);
      }
      
      draw_text(32, 32 + (i * 32), total);
    
    Powyższy kod zsumuje wszystkie wartości w naszej tablicy, narysuje każdą z nich, a następnie na końcu narysuje wartość całkowitą.
           Usuwanie tablic
    Ostatnią rzeczą, o której należy wspomnieć w odniesieniu do tablic, jest to, że można je usunąć, po prostu "przypisując" zmiennej, która je definiuje, pojedynczą wartość. Spowoduje to zwolnienie pamięci związanej ze wszystkimi pozycjami i wartościami tej tablicy. Na przykład:
    // Create an arrayfor (var i = 9; i > -1; --i)
      {
          a[i] = i;
      }
      
      // Delete the array
      a = -1;
    
    Jeśli tablica ma wiele wymiarów (patrz niżej), zostaną one również wyczyszczone. Zauważ, że gdy tworzysz tablice w instancjach, nie trzeba ich czyścić, gdy instancja zostanie usunięta z gry, ponieważ zostaną one automatycznie usunięte przez garbage collector w momencie Destroy lub Room End. Jeśli jednak w którejś z pozycji tablicy znajdują się odwołania do dynamicznych zasobów, takich jak systemy cząsteczek, buffers lub struktury danych, będą one musiały zostać zniszczone przed usunięciem tablicy, zniszczeniem instancji lub zakończeniem room.
     
  
  Tablice wielowymiarowe
  
    Wiemy już, czym jest tablica jednowymiarowa, ale w GameMakerze można mieć tablice wielowymiarowe, które są skonstruowane jako tablica wewnątrz tablicy wewnątrz tablicy... Na przykład poniżej przedstawiono tablicę 2D (dwuwymiarową):
    array[0][0] = 5;
    Jest to w zasadzie informacja dla GameMaker, że tablica składa się z różnych tablic 1D. Oto rozszerzony przykład:
    array[0][0] = 0;
      array[0][1] = 1;
      array[0][2] = 2;
      
      array[1][0] = 3;
      array[1][1] = 4;
      array[1][2] = 5;
    
    W powyższym kodzie adres array[0] zawiera inną tablicę, podobnie jak adres array[1].
    Tablica wielowymiarowa wymaga inicjalizacji przed użyciem, tak samo jak pojedyncza tablica 1D, i może przechowywać liczby rzeczywiste, strings oraz wszelkie inne typy danych, tak jak każda inna zmienna, co czyni je idealnymi kandydatami do każdej gry, która musi przechowywać duże ilości danych w łatwo dostępny sposób (pamiętaj, że możesz loop łatwo przeglądać tablicę).
    W jednym wyrażeniu można również zainicjować tablicę wielowymiarową, zagnieżdżając w niej tablice jednowymiarowe:
    two_dimensional_array = 
      [
          ["Apple", 10, 2],
          ["Orange", 5, 2],
          ["Mango", 15, 4],
          // ...and so on.
      ]
     [n] Tablice wielowymiarowe nie ograniczają się tylko do dwóch wymiarów. W kodzie można dodać 3, 4 lub więcej wymiarów do tablicy, dodając kolejne argumenty, np:
    array[0][0][0] = 1;     // A three dimensional array
      array[0][0][0][0] = 1;  // A four dimensional array
      // etc...
    Należy również zauważyć, że długość każdego wymiaru w tablicy może być różna, więc początkowy wymiar tablicy może mieć długość 3, ale drugi wpis wymiaru może mieć inną długość dla każdego gniazda w pierwszym wymiarze; na przykład:
    array[2][2] = "3";
      array[2][1] = "2";
      array[2][0] = "1";
      
      array[1][3] = "four";
      array[1][2] = "three";
      array[1][1] = "two";
      array[1][0] = "one";
      
      array[0][1] = 2;
      array[0][0] = 1;
    
    W powyższym kodzie na stronie array[0] znajdują się 2 gniazda, na stronie array[1] - 4 gniazda, a na stronie array[2] - 3 gniazda.
           Przykład rozszerzony
    Oto ostatni przykład zastosowania tego rozwiązania w rzeczywistej grze: Powiedzmy, że chcemy wywołać czterech różnych wrogów w czterech różnych punktach gry, w zależności od losowej wartości. Do tego celu możemy użyć tablicy o dwóch wymiarach, oszczędzając sobie pisania całego kodu.
    Najpierw powinniśmy zainicjować tablicę, której będziemy używać w zdarzeniu Create naszego "kontrolera" object (zwróć uwagę na komentarze przypominające, co robi każdy element tablicy):
    enemy[3][2] = 448;       //y position
      enemy[3][1] = 32;        //x position
      enemy[3][0] = obj_Slime; //Object
      enemy[2][2] = 448;
      enemy[2][1] = 608;
      enemy[2][0] = obj_Skeleton;
      enemy[1][2] = 32;
      enemy[1][1] = 608;
      enemy[1][0] = obj_Knight;
      enemy[0][2] = 32;
      enemy[0][1] = 32;
      enemy[0][0] = obj_Ogre;
    W naszej tablicy znajdują się teraz instancje objects do wywołania oraz odpowiadające im współrzędne x i y w obrębie room. Można to teraz wykorzystać w innym zdarzeniu kontrolera object (na przykład w alarmie lub zdarzeniu naciśnięcia klawisza):
    //get a random number from 0 to 3, inclusive
      var i = irandom(3);
      
      //Use the array to create the object
      instance_create_layer(enemy[i][1], enemy[i][2], "Enemy_Layer", enemy[i][0]);
    
    Ten krótki kod będzie teraz wywoływał losowego przeciwnika w grze room i używa o wiele mniej kodu niż struktura "if / then / else" lub nawet "switch", a ponieważ tablica jest inicjalizowana w zdarzeniu tworzenia, o wiele łatwiej jest edytować i zmieniać dowolne wartości, ponieważ nie są one na stałe zakodowane w reszcie kodu projektu.
  
   
  Tablice jako argumenty funkcji
  Można przekazywać tablice do funkcji skryptu i zmiennych metod jako argumenty, a następnie modyfikować te tablice w dowolnym miejscu wewnątrz funkcji. W ten sposób modyfikuje się również oryginalne tablice.
  Na przykład ta funkcja po prostu zmienia trzy pierwsze elementy przekazanej jej tablicy:
  modify_array = function (array)
    {
        array[0] = 2;
        array[1] = 4;
        array[2] = 6;
    }
  Można teraz utworzyć tablicę i przekazać ją do tej funkcji, która zmodyfikuje tablicę:
  my_array = [100, 4, 214];
    
    modify_array(my_array);
    
    show_debug_message(my_array); // Prints [2, 4, 6];
  
  W poprzednich wersjach GameMaker nie było to możliwe, ponieważ modyfikacja tablicy wewnątrz funkcji powodowała utworzenie kopii. To przestarzałe zachowanie nadal można włączyć, jeśli jest to pożądane: przeczytaj sekcję "Kopiowanie przy zapisie" poniżej, aby uzyskać więcej informacji.
  Kopiuj na Napisz
   Opcja Kopiuj przy zapisie jest przestarzała i jest używana tylko wtedy, gdy w opcjach ogólnych gry włączona jest opcja "Włącz zachowanie Kopiuj przy zapisie dla tablic". W tym rozdziale opisano zachowanie tablic, gdy ta opcja jest włączona.
  Jak opisano w poprzednim rozdziale, tablice można przekazywać do funkcji jako argumenty. W tym celu wystarczy podać zmienną tablicową (nie trzeba podawać poszczególnych pozycji ani nawiasów [] ), a cała tablica zostanie przekazana do funkcji przez referencję:
  my_array = [1, 2, 4, 8, 16];
    
    do_something(my_array);
  
  Jednak gdy włączona jest opcja Kopiuj przy zapisie, zmiana dowolnej wartości tablicy wewnątrz funkcji powoduje utworzenie tymczasowej kopii z wprowadzonymi zmianami. Oryginalna tablica nie jest modyfikowana. Takie zachowanie nazywa się Kopiowanie przy zapisie.
  Aby faktycznie zmodyfikować oryginalną tablicę, która została przekazana do funkcji, należy albo zwrócić ją z powrotem, albo użyć argumentu dostępu @.
  Na przykład funkcja wywołana powyżej, do_something(), może wykonać coś tak prostego, jak poniżej:
  do_something = function(array)
    {
        array[1] = 200;
    }
  Można by oczekiwać, że moja_tablica będzie miała wartości 1, 200, 4 itd., co w normalnych warunkach byłoby poprawne - ale gdy włączone jest kopiowanie przy zapisie, oryginalna tablica pozostaje nienaruszona.
  Aby obejść ten problem, można sprawić, że funkcja zwróci zmodyfikowaną kopię tablicy, a następnie zastosuje ją z powrotem do oryginalnej zmiennej:
  my_array = [1, 2, 4, 8, 16];
    
    my_array = do_something(my_array);
  
  Sama funkcja zwróciłaby zmodyfikowaną tablicę:
  do_something = function(array)
    {
        array[1] = 200;
    
        return array;
    }
  
  UWAGA Powyższy kod nie jest konieczny, jeśli nie zmieniamy żadnej z wartości tablicy, a jedynie odwołujemy się do nich. Odwołanie do tablicy nie spowoduje jej skopiowania i będzie szybsze w parsowaniu.
  Drugim rozwiązaniem jest użycie dostępnika @ do bezpośredniej zmiany wartości tablicy, co pozwala zaoszczędzić obciążenie procesora związane z tworzeniem tymczasowej kopii. Oznacza to, że nie trzeba zwracać tablicy z funkcji i można ją bezpośrednio edytować:
  do_something = function(array)
    {
        array[@ 1] = 200;
    }
  Użycie tego dostępnika pozwala ominąć zachowanie Kopiuj przy zapisie i bezpośrednio zmodyfikować tablicę, do której się odwołujemy. Może to być użyte do selektywnego wyłączenia funkcji Kopiuj przy zapisie dla określonych instrukcji, przy jednoczesnym utrzymaniu tej opcji włączonej.
  Ponownie, wszystkie te czynności nie są konieczne, jeśli opcja Kopiuj przy zapisie jest wyłączona (co jest opcją domyślną i zalecaną).
  Więcej informacji na temat akcesorów i sposobu ich działania, wraz z przykładem dotyczącym tablic, można znaleźć na następującej stronie:
  
    Akcesoria
  
   
   
   
  
    
      
        Powrót: Przegląd GML
        Następny: Struktury i konstruktory
      
    
    © Copyright YoYo Games Ltd. 2022 Wszystkie prawa zastrzeżone.
  
  
  

