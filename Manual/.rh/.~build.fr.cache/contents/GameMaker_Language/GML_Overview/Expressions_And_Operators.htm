
  
  Wyrażenia i operatory
  Wyrażenia
  Wyrażenie to wyrażenie matematyczne, które może zawierać zwykłe liczby, zmienne, strings, lub funkcje, a także jeden lub więcej operatorów (takich jak dodawanie, odejmowanie, mnożenie itd...). Wartości używane w wyrażeniu mogą być liczbami rzeczywistymi (np. 3.4 * 6), liczbami szesnastkowymi zaczynającymi się od znaku $ (np. $00FFAA | $88FFAA), strings w cudzysłowie (np. "hello" + "world") lub bardziej skomplikowanymi wyrażeniami wykorzystującymi wiele operatorów i wartości.
  Operatorzy
  W wyrażeniach można stosować następujące operatory:
  Przypisanie (=)
  
    = służy do przypisywania wartości do zmiennej. Zauważ, że można go także użyć do porównywania zmiennych w GameMakerze i możesz to zobaczyć w przykładach i kodach innych osób. Jest to jednak pozostałość po starych wersjach GameMakera i powinieneś używać operatorów == do porównywania i = do przypisywania, jak pokazano w poniższych przykładach:
    a = 12;
      speed = 5;
      val = (old_val + 5);
     
  
  Łączenie (&&, ||, ^^)
  
    &&, ||, ^^ (and, or i xor ) są używane do łączenia wartości logicznych w celu uzyskania wartości true lub false. Jeśli którykolwiek z poniższych przykładów zostanie rozwiązany przez true, kod zostanie uruchomiony:
    if (a == b && c == d) { do something... }  // and
      if (a == b || c == d) { do something... }   // or
      if (a == b ^^ c == d) { do something... }  // xor
     
  
  Nullish (??, ??=)
  
    UWAGA "Nullish" odnosi się po prostu do wartości równej undefined lub pointer_null.
    ?? to zerowy operator koalescencji, który zwraca określone wyrażenie, jeśli podana wartość jest niezdefiniowana lub pointer_null. Operator ten wymaga następującej składni:
    (input ?? null_output)
    Jeśli dane wejściowe są niezdefiniowane lub pointer_null, wyrażenie zwróci wartość null_output; jednak we wszystkich innych przypadkach zwróci po prostu wartość wejściową. Można tego użyć do zdefiniowania "domyślnej" wartości zmiennej, na wypadek gdyby sama zmienna nie posiadała poprawnej wartości.
    Rozważmy następujący przykład:
    username = data.username ?? "INVALID USERNAME";
    W tym przypadku zmienna username otrzyma wartość zapisaną w data.username, jednak jeśli data.us ername będzie niezdefiniowana lub pointer_null, zmienna otrzyma zamiast tego string "INVALID USERNAME". Przykład ten gwarantuje, że wywołania funkcji korzystających ze zmiennej username nie spowodują błędu z powodu otrzymania wartości null oraz że użytkownik będzie wiedział, kiedy jego nazwa użytkownika nie została zwrócona.
    UWAGA Wyrażenie po prawej stronie operatora koalescencji nullish jest wykonywane tylko wtedy, gdy wartość wejściowa jest nullish, co oznacza, że wszelkie wywołania funkcji zawarte w wyrażeniu RHS będą wykonywane tylko wtedy, gdy wartość wejściowa jest nullish.
    
    ??= jest podobny do opisanego powyżej operatora koalescencji nullish, ale jest używany specjalnie do przypisywania zmiennych. Operator ten wymaga następującej składni:
    variable ??= null_value
    Jeśli zmienna jest niezdefiniowana lub pointer_null, zostanie jej przypisana wartość null_value; w przeciwnym razie zmienna pozostanie niezmieniona. Można tego użyć do przypisania zmiennej niestandardowej, "domyślnej" wartości, gdy przechowuje ona wartość null.
     
  
  Porównywanie (<, <=, ==, !=, >, >=)
  
    <, <=, ==, !=, >, > = są porównaniami i mogą dawać tylko wynik true lub false (gdzie true może być również interpretowane jako 1, a false jako 0). Przykłady użycia:
    if (a < b) {do something...}
      if (a != b) {do something...}
     
  
  Bitowe (|, &, ^, <<, >>)
  
    |, &, ^, <<, >> służą do wykonywania operacji bitowych, gdzie | = bitowe lub, & = bitowe i, ^ = bitowe xor, << = przesunięcie w lewo, >> = przesunięcie w prawo. Przykłady użycia:
    x = (x & $ffffffe0) + 32;
      if (y ^ $1f) > 0 {do something...};
    Dodatkowe informacje na temat używania operatorów bitowych i ich działania można znaleźć w rozdziale: Operatory bitowe.
     
  
  Arytmetyczne (+, -, *, /)
  
    +, -, *, / oznaczają odpowiednio dodawanie, odejmowanie, mnożenie i dzielenie. Przykłady użycia:
    c = a * b;
      str = a + "world";
    UWAGA Liczby zmiennoprzecinkowe nie zatrzymują się na dzieleniu przez zero, ponieważ w odpowiedzi otrzymają nieskończoność. Jeśli A i B są liczbami całkowitymi (int32 lub int64), to dzielenie zostanie wykonane jako dzielenie przez liczby całkowite (zostanie sprawdzone dzielenie przez 0 i zostanie usunięty błąd). W przeciwnym razie zostanie wykonane dzielenie zmiennoprzecinkowe (bez sprawdzania dzielenia przez 0).
     
  
  Zwiększanie/ zmniejszanie (++, --)
  
    ++, -- służą do dodawania lub odejmowania jednego(1) od wartości. Warto zauważyć, że umieszczenie tego przed lub po wartości, do której ma być dodane lub od której ma być odjęte, daje nieco inne wyniki. Na przykład:
    
      ++a spowoduje inkrementację zmiennej i zwróci jej zwiększoną wartość.
      a++ spowoduje inkrementację zmiennej, ale zwróci wartość sprzed jej inkrementacji.
    
    Dlatego też, jeśli masz coś takiego:
    var a = 1;
      show_debug_message(string(a++));
      show_debug_message(string(++a));
    Wyjściem debugowania byłyby wartości 1 i 3. Oto kilka przykładów użycia:
    for (var i = 0; i < 10; i++;)
      {
          do something...
      }
    if (hit == true)
      {
          --score;
      }
    UWAGA: Na platformach docelowych kompilatora YoYo (oznaczonych (YYC)) wyrażenia te są obliczane od lewej do prawej, podczas gdy na wszystkich innych platformach docelowych są one obliczane od prawej do lewej, co oznacza, że:
    val = max(num, ++num, num++);
    daje różne wyniki w zależności od platformy.
     
  
  Dzielenie i modulo (div, %, mod)
  
    div, mod (% ) to dzielenie i modulo, gdzie div określa, na ile wartości można podzielić, uzyskując tylko iloraz całkowity, a mod określa tylko resztę z dzielenia. Zauważ, że dzielenie i modulowanie można wykonywać tylko przy użyciu wartości całkowitych. Przykłady użycia: 
    secs = time mod 60;
      time_str = string(time div 60);
     
  
  Jednoargumentowe (!, -, ~)
  
    Dostępne są następujące operatory jednoargumentowe:
    
      !: boolean "nie", więc !true == false
      -: neguje następną wartość rzeczywistą lub całkowitą (nie dotyczy strings lub booleans)
      ~: neguje następną wartość bitowo
    
     
  
  Grupowanie wyrażeń
  Jako wartości we wszystkich wyrażeniach można używać liczb, zmiennych lub funkcji, które zwracają wartość, a podwyrażenia można umieszczać również w nawiasach. Wszystkie operatory działają dla wartości liczb rzeczywistych, ale porównania działają również dla strings, a operator "+" może być używany do łączenia łańcuchów.
  W przypadku wykonywania wielu operacji w jednym wyrażeniu bardzo ważne jest użycie nawiasów () w celu oddzielenia kolejności operacji, ponieważ różne platformy mogą wykonywać je w różny sposób, jeśli nie zostaną wyraźnie określone w ten sposób. Na przykład rozważmy następujący kod:
  a = b == c || d;
  Różne docelowe kompilatory będą wykonywać operacje w różnej kolejności, ponieważ nie są one wyraźnie pokazane, co może prowadzić do "dziwnych" wyników, których nie spodziewasz się podczas gry. aby tego uniknąć, użyj (), aby oddzielić poszczególne części, tak jak poniżej:
  a = (b == c || d);   //better
    a = ((b == c) || d); //best
  Grupowanie zestawień
  W przypadku używania różnych operacji i wyrażeń w jednym bloku kodu, również one powinny być rozdzielone. Na przykład poniższy kod wygląda na poprawny:
  if my_var == your_var ++their_var;
  Jednak kompilator może to zinterpretować na jeden z dwóch sposobów:
  if my_var == your_var++ then their_var;
    
    // or
    
    if my_var == your_var then ++their_var;
  
  Patrząc na kod, można stwierdzić, że jedno z tych rozwiązań jest nieco głupie, ale to dlatego, że my wiemy, co chcemy osiągnąć i co ma się wydarzyć, ale kompilator tego nie wie. Widzi on jedynie dwie zmienne z operatorem ++ między nimi, więc musi wybrać, do której z nich go zastosować. Dlatego zawsze należy wyraźnie nawiasować wyrażenia, operacje i instrukcje. Poprawna wersja powyższego kodu powinna wyglądać następująco:
  if (my_var == your_var)
    {
        ++their_var;
    }
  Może się to wydawać bardziej czasochłonne, ale nie ma żadnych niejasności co do wykonywanych operacji i będzie się kompilować i zachowywać spójnie na wszystkich platformach. Należy również pamiętać, że chociaż obecnie można tworzyć łańcuchy wyrażeń i instrukcji bez użycia nawiasów, jest to funkcja starsza i w przyszłości może zostać zdeprecjonowana i usunięta z GML, dlatego też odpowiednie użycie nawiasów już teraz "uodporni" kod na przyszłość (i jest ogólnie dobrą praktyką).
  Oto kilka ostatnich przykładów różnych wyrażeń:
  {
        x = 23 div 2;
        colour = $FFAA00 + $00BB12;
        str = "hello" + "world";
        y += 5;
        x *= y;
        x = y << 2;
        x = 23 * ((2 + 4) / sin(y));
        b = (x < 5) && !((x == 2) || (x == 4));
    }
  Ostatnią rzeczą, na którą warto zwrócić uwagę, jest to, że istnieją pewne "skróty" wyrazowe, zwane accessorami, przeznaczone do stosowania z niektórymi strukturami danych i tablicami. Umożliwiają one szybkie i łatwe dodawanie lub zastępowanie danych w tych formatach bez konieczności wywoływania jakichkolwiek funkcji. Szczegółowe informacje można znaleźć na następującej stronie
  
    Akcesoria
  
   
   
   
  
    
      
        Powrót: Przegląd GML
        Następny: Funkcje i zmienne skryptu
      
    
    © Copyright YoYo Games Ltd. 2022 Wszystkie prawa zastrzeżone.
  
  
  

