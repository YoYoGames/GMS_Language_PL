
    Słowa kluczowe instancji
    Aby ułatwić sobie pewne rzeczy w programie GameMaker, możesz użyć w swoim kodzie jednego z kilku słów kluczowych instancji (czy to GML, czy GML Visual). Te słowa kluczowe służą przede wszystkim do identyfikowania instancji - a w niektórych przypadkach także structs - w różnych sytuacjach, a każde z nich jest wyjaśnione w poniższym tekście.
    Zauważ, że wszystkie podane słowa kluczowe są wewnętrznie reprezentowane przez ujemne wartości całkowite, więc należy zachować ostrożność podczas przypisywania lub sprawdzania wartości zmiennych względem lub z tymi słowami kluczowymi, ponieważ możesz później uzyskać nieoczekiwane wyniki, gdy GameMaker zinterpretuje wartość, której użyłeś, jako coś innego. Należy również pamiętać, że używanie w kodzie wartości całkowitych bezpośrednio zamiast słów kluczowych nie jest zalecane i może być przyczyną późniejszych problemów.
    self
    
      
        
          
            Słowo kluczowe
            Opis
            wartość
          
          
            self
            Instancja/struktura, która wykonuje bieżący blok kodu.
               -1
          
        
      
      self można użyć do zidentyfikowania bieżącej strony struct lub instancji, która jest objęta zakresem w bieżącym bloku kodu. Na przykład:
      var val = 100;
        
        with (instance_create_layer(x, y, "Instances", obj_Fire))
        
        {
        
        self.val = val;
        
        }
      W tym przykładzie widać, że mamy zmienną lokalną o nazwie val i chcemy, aby ustawiła ona zmienną instancji o tej samej nazwie w nowo utworzonej instancji object. Aby poprawnie zidentyfikować zmienną instancji i powiedzieć programowi GameMaker, by ustawił ją w instancji wywołującej blok kodu, używamy słowa kluczowego self. W większości przypadków można też używać wbudowanej zmiennej instancji id zamiast self, ale self oferuje pewne korzyści. Po pierwsze, kompilator szybciej identyfikuje instancję (lub struct) za pomocą self niż id, ponieważ wartość id przechodzi przez tabelę wyszukiwania instancji, podczas gdy self nie. Po drugie, dla osób tworzących extensions bardzo przydatne jest zapewnienie poprawnego zakresu zmiennych, ponieważ może się zdarzyć, że projekt używający extension będzie miał zmienną o zakresie globalnym lub coś o takiej samej nazwie jak zmienna w extension.
      UWAGA: Słowo kluczowe self nie jest skrótem do rzeczywistej wartości ID instancji lub struct i powinno być używane tylko w kontekście wyjaśnionym powyżej. Jeśli potrzebujesz wartości ID dla instancji, musisz użyć self.id, np:
      var myID = id;
        
        with (all)
        
        {
        
        if self.id == myID
        
        {
        
        // do something
        
        }
        
        }
      Warto również zauważyć, że self może być również używany wewnątrz struktur - w bardzo szczególnych okolicznościach - do odwoływania się do zmiennych członkowskich dla struct.
       
    
    other
    
      
        
          
            Słowo kluczowe
            Opis
            wartość
          
          
            other
            Druga instancja uczestnicząca w zdarzeniu kolizyjnym, w funkcji with lub w funkcji.
               -2
          
        
      
      Specjalnego słowa kluczowego other można użyć na wiele sposobów, aby odwołać się do konkretnej instancji (a w niektórych przypadkach do struct): można go użyć w instrukcji with (wyjaśniono tutaj), w zdarzeniu kolizji lub w funkcji. W tym rozdziale zostaną wyjaśnione dwa ostatnie przypadki użycia.
      Należy pamiętać, że w zdarzeniach innych niż zderzenie, poza wywołaniami funkcji i blokami with(), other zwraca po prostu adres struct dla bieżącej instancji.
      Zdarzenie kolizyjne
      Zdarzenie kolizji może wystąpić tylko między dwiema instancjami. Możesz mieć wiele kolizji między wieloma instancjami, ale wszystkie one są rozwiązywane przez GameMaker na zasadzie 1 na 1, z instancją "własną", która ma zdarzenie kolizji i "drugą" instancją, która się z nią zderza.
      Wyobraź sobie, że masz instancję gracza, wiele instancji przeciwnika i wiele instancji pocisków, które przeciwnik może wystrzelić w twoją stronę. Możesz przypisać każdemu wrogowi jedną instancję pocisku, ale z inną zmienną obrażeń, losowo przypisaną do niego podczas tworzenia:
      var bullet;
        
        bullet = instance_create_layer(x, y, "Bullets", obj_Bullet);
        
        bullet.damage = 5 + irandom(5);
        
        bullet.speed = 8;
        
        bullet.direction = point_direction(x, y, obj_Player.x, obj_Player.y);
      Możesz zobaczyć, jak ustawiamy jego zmienne, używając notacji kropkowej, tak jak to opisano w rozdziale Adresowanie zmiennych w innych instancjach. Dzięki temu każda instancja pocisku będzie miała inną wartość obrażeń, ale w jaki sposób gracz wykryje obrażenia, które musi przyjąć, gdy zostanie trafiony pociskiem?
      W tym celu gracz będzie musiał utworzyć zdarzenie kolizji z obj_Bullet, a w tym zdarzeniu użyć other do odczytania zmiennych z instancji zderzającego się pocisku:
      hp -= other.damage;
        
        if hp <= 0 instance_destroy();
      Powyższy kod odejmie kwotę zapisaną w zmiennej "damage" drugiej instancji od zmiennej "hp" gracza, a następnie sprawdzi, czy "hp" jest mniejsze lub równe 0. Jeśli tak, to zniszczy instancję gracza. Zwróć uwagę, że druga instancja musi mieć sprawdzaną zmienną, w przeciwnym razie zostanie wyświetlony błąd.
      UWAGA: Zdarzenie Kolizja jest jedynym zdarzeniem, które ma specjalne znaczenie dla słowa kluczowego other. We wszystkich innych zdarzeniach oraz na stronie scripts zachowanie słowa other będzie określone przez kontekst, w którym jest ono używane (np. blok with() , funkcja, deklaracja struct itd.).
      Zmiennym można przypisywać wartości, a nawet tworzyć nowe, używając adresu other w zdarzeniu kolizji, jak poniżej:
      // add ten to the other instance "mana" variable
        
        other.mana += 10;
        
        // set the other instance variable "hit" to true, creating the variable if it doesn't already exist
        
        other.hit = true;
      Deklaracja struktury
      Gdy jest użyta wewnątrz deklaracji struct, other odnosi się do instancji inicjalizującej strukturę:
      var _struct =
        
        {
        
        parent_instance : other
        
        }
        
        
        show_debug_message(_struct.parent_instance == self);
        
        // This prints '1' (true) meaning that both sides refer to the same instance 
      Nie musisz jednak używać other do odczytywania zmiennych z instancji, ponieważ wszystkie zmienne, do których odwołujesz się bezpośrednio, zostaną odczytane z zakresu tej instancji, jak opisano w tej części podręcznika. Musiałbyś tego użyć tylko wtedy, gdybyś chciał przechowywać odwołanie do zmiennych tej instancji struct.
      Metoda instancji
      Użycie other wewnątrz metody innej instancji method odnosi się do instancji, która wywołała tę metodę.
      Na przykład, załóżmy, że Object2 ma metodę, która odwołuje się do self i other. Metoda ta jest następnie wywoływana w Object1. Ponieważ metoda ta została utworzona w Object2, jest z nią związana i zawsze będzie używać instancji Object2 jako "self", niezależnie od tego, która instancja ją wywoła. W takim przypadku instancją wywołującą staje się other.
      // In Object2
        
        my_method = function()
        
        {
        
        show_debug_message(object_get_name(self.object_index));
        
        show_debug_message(object_get_name(other.object_index));
        
        }
        
        
        // In Object1
        
        Object2.my_method(); 
      Spowoduje to, że instancja najpierw wypisze swoją własną nazwę object ("Object2"), a następnie nazwę object instancji wywołującej ("Object1").
      To samo dotyczy metody, która jest związana z adresem struct.
      Funkcja konstruktora
      Gdy zostanie użyty wewnątrz funkcji konstruktora, other będzie odwoływał się do instancji wywołującej tę funkcję, jednak nie jest to zalecane do ogólnego użytku, ponieważ wszelkie zewnętrzne dane, z których konstruktor musi korzystać, powinny być przekazywane jako argumenty.
       
    
    all
    
      
        
          
            Słowo kluczowe
            Opis
            wartość
          
          
            all
            Wszystkie instancje aktualnie aktywne w serwisie room.
               -3
          
        
      
       
      Tego słowa kluczowego używa się, aby powiedzieć programowi GameMaker, że funkcja ma być zastosowana lub sprawdzona we wszystkich aktywnych instancjach w room (instancje wyłączone nie będą sprawdzane ani udostępniane). Nie możesz użyć all, by uzyskać dostęp do zmiennych w innych instancjach lub ustawić je za pomocą metody punktowej (zobacz tutaj), ale możesz go użyć przy wywołaniu with()na przykład:
      with (all)
        
        {
        
        speed = 0;
        
        }
      Powyższy kod ustawi prędkość wszystkich instancji w room na 0. Można także użyć all w funkcjach, aby na przykład skierować lub sprawdzić wszystkie instancje w room:
      // Check a point for any active instance in the room
        
        inst = instance_position(mouse_x, mouse_y, all);
        
        
        // Check all instances for a collision along a line
        
        if collision_line(x, y, mouse_x, mouse_y, all, false, true) {}
        
        
        // Add all instances in the room into a motion planning grid
        
        mp_grid_add_instances(grid, all, false); 
      all jest bardzo użytecznym słowem kluczowym i może być używane w wielu sytuacjach w kodzie i działaniach, często zmniejszając ilość kodu, który trzeba napisać, aby osiągnąć pożądany efekt.
       
    
    noone
    
      
        
          
            Słowo kluczowe
            Opis
            wartość
          
          
            noone
            Nie ma żadnego przypadku.
               -4
          
        
      
      Może się to wydawać dziwne, ale wiele razy podczas programowania gier pojawia się potrzeba sprawdzenia, czy w danej lokacji, w danej kolizji itp. nie ma żadnych instancji. W takich przypadkach użyjesz tego słowa kluczowego, aby sprawdzić, czy nic nie ma, na przykład tak:
      if instance_nearest(x, y, obj_enemy) != noone
        
        {
        
        //do something as there is an enemy instance near
        
        }
      W tym przykładzie funkcja instance_nearest() zwróci albo noone, albo unikatowy identyfikator najbliższej znalezionej instancji. Zasadniczo za każdym razem, gdy chcesz sprawdzić, czy istnieje jakaś instancja, możesz oczekiwać, że zwrócona zostanie albo noone, albo unikalny identyfikator instancji.
       
    
     
     
     
    
      
        
          Powrót: Przegląd GML
          Następny: Kolejność oceniania
        
      
      © Copyright YoYo Games Ltd. 2022 Wszystkie prawa zastrzeżone.
    
    
