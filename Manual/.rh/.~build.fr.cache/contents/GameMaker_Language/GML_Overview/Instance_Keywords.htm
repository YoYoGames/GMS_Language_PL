
  
  Słowa kluczowe instancji
  Aby ułatwić pewne rzeczy w GameMaker Studio 2, możesz użyć jednego z kilku słów kluczowych instancji w swoim kodzie (zarówno GML, jak i Drag and Drop™). Te słowa kluczowe służą przede wszystkim do identyfikowania instancji - a w niektórych przypadkach structs - w różnych sytuacjach, a każde z nich jest wyjaśnione w poniższym tekście.
  Zwróć uwagę, że wszystkie podane słowa kluczowe są wewnętrznie reprezentowane przez ujemne wartości całkowite, więc należy zachować ostrożność podczas przypisywania lub sprawdzania wartości zmiennych względem lub z tymi słowami kluczowymi, ponieważ możesz później uzyskać nieoczekiwane wyniki, gdy GameMaker Studio 2 zinterpretuje wartość, której użyłeś, jako coś innego. Należy również pamiętać, że używanie w kodzie wartości całkowitych bezpośrednio zamiast słów kluczowych nie jest zalecane i może być przyczyną późniejszych problemów.
   
  self
  
    
      
        
          Słowo kluczowe
          Opis
          wartość
        
        
          self
          Instancja/struktura, która wykonuje bieżący blok kodu.
             -1
        
      
    
    self można użyć do zidentyfikowania bieżącej strony struct lub instancji, która jest objęta zakresem w bieżącym bloku kodu. Na przykład:
    var val = 100;
      with (instance_create_layer(x, y, "Instances", obj_Fire))
      {
          self.val = val;
      }
    W tym przykładzie widać, że mamy zmienną lokalną o nazwie val i chcemy, aby ustawiła ona zmienną instancji o tej samej nazwie w nowo utworzonej instancji object. Aby poprawnie zidentyfikować zmienną instancji i powiedzieć GameMaker Studio 2, by ustawiła ją w instancji wywołującej blok kodu, używamy słowa kluczowego self. W większości przypadków zamiast self można też użyć wbudowanej zmiennej instancji id, ale self oferuje pewne korzyści. Po pierwsze, kompilator szybciej identyfikuje instancję (lub struct) za pomocą self niż id, ponieważ wartość id przechodzi przez tabelę wyszukiwania instancji, a self nie. Po drugie, dla osób tworzących extensions bardzo przydatne jest zapewnienie poprawnego zakresu zmiennych, ponieważ może się zdarzyć, że projekt używający extension będzie miał zmienną o zakresie globalnym lub coś o takiej samej nazwie jak zmienna w extension.
    UWAGA: Słowo kluczowe self nie jest skrótem do rzeczywistej wartości ID instancji lub struct i powinno być używane tylko w kontekście wyjaśnionym powyżej. Jeśli potrzebujesz wartości ID dla instancji, musisz użyć self.id, np:
    var myID = id;
      with (all)
      {
          if self.id == myID
          {
              // do something
          }
      }
    Warto również zauważyć, że self może być również używany wewnątrz struktur - w bardzo szczególnych okolicznościach - do odwoływania się do zmiennych członkowskich dla struct.
     
  
  other
  
    
      
        
          Słowo kluczowe
          Opis
          wartość
        
        
          other
          Druga instancja uczestnicząca w zdarzeniu kolizyjnym, w funkcji with lub w funkcji.
             -2
        
      
    
    Specjalnego słowa kluczowego other można użyć na wiele sposobów, aby odwołać się do konkretnej instancji (a w niektórych przypadkach do struct): można go użyć w instrukcji with (wyjaśniono tutaj), w zdarzeniu kolizji lub w funkcji. W tym rozdziale zostaną wyjaśnione dwa ostatnie przypadki użycia.
    Należy pamiętać, że w zdarzeniach innych niż zderzenie, poza wywołaniami funkcji i blokami with(), other zwraca po prostu adres struct dla bieżącej instancji.
    Zdarzenie kolizyjne
    Zdarzenie kolizji może wystąpić tylko między dwiema instancjami. Możesz mieć wiele kolizji między wieloma instancjami, ale wszystkie one są rozwiązywane przez GameMaker Studio 2 na zasadzie 1 na 1, z instancją "własną", która ma zdarzenie kolizji i "inną" instancją, która się z nią zderza.
    Wyobraź sobie, że masz instancję gracza, wiele instancji przeciwnika i wiele instancji pocisków, które przeciwnik może wystrzelić w twoją stronę. Możesz przypisać każdemu wrogowi jedną instancję pocisku, ale z inną zmienną obrażeń, losowo przypisaną do niego podczas tworzenia:
    var bullet;
      bullet = instance_create_layer(x, y, "Bullets", obj_Bullet);
      bullet.damage = 5 + irandom(5);
      bullet.speed = 8;
      bullet.direction = point_direction(x, y, obj_Player.x, obj_Player.y);
    Możesz zobaczyć, jak ustawiamy jego zmienne, używając notacji kropkowej, tak jak to opisano w rozdziale Adresowanie zmiennych w innych instancjach. Dzięki temu każda instancja pocisku będzie miała inną wartość obrażeń, ale w jaki sposób gracz wykryje obrażenia, które musi przyjąć, gdy zostanie trafiony przez pocisk?
    W tym celu gracz będzie musiał utworzyć zdarzenie kolizji z obj_Bullet, a w tym zdarzeniu użyć other do odczytania zmiennych z instancji zderzającego się pocisku:
    hp -= other.damage;
      if hp <= 0 instance_destroy();
    Powyższy kod odejmie kwotę zapisaną w zmiennej "damage" drugiej instancji od zmiennej "hp" gracza, a następnie sprawdzi, czy "hp" jest mniejsze lub równe 0. Jeśli tak, to zniszczy instancję gracza. Zwróć uwagę, że druga instancja musi posiadać sprawdzaną zmienną, w przeciwnym razie zostanie wyświetlony błąd.
    UWAGA: Zdarzenie Kolizja jest jedynym zdarzeniem, które ma specjalne znaczenie dla słowa kluczowego other. We wszystkich innych zdarzeniach oraz na stronie scripts zachowanie słowa other będzie określone przez kontekst, w którym jest ono używane (np. blok with() , funkcja, deklaracja struct itd.).
    Zmiennym można przypisywać wartości, a nawet tworzyć nowe, używając adresu other w zdarzeniu kolizji, jak poniżej:
    // add ten to the other instance "mana" variable
      other.mana += 10;
      // set the other instance variable "hit" to true, creating the variable if it doesn't already exist
      other.hit = true;
    Deklaracja struktury
    Gdy jest użyta wewnątrz deklaracji struct, other odnosi się do instancji inicjalizującej strukturę:
    var _struct =
      {
          parent_instance : other
      }
      
      show_debug_message(_struct.parent_instance == self);
      // This prints '1' (true) meaning that both sides refer to the same instance
    
    Nie musisz jednak używać other do odczytywania zmiennych z instancji, ponieważ wszystkie zmienne, do których odwołujesz się bezpośrednio, zostaną odczytane z zakresu tej instancji, jak opisano w tej części podręcznika. Musiałbyś tego użyć tylko wtedy, gdybyś chciał przechowywać odwołanie do zmiennych tej instancji struct.
    Metoda instancji
    Użycie other wewnątrz metody innej instancji method odnosi się do instancji, która wywołała tę metodę.
    Na przykład, załóżmy, że Object2 ma metodę, która odwołuje się do self i other. Metoda ta jest następnie wywoływana w Object1. Ponieważ metoda ta została utworzona w Object2, jest z nią związana i zawsze będzie używać instancji Object2 jako "self", niezależnie od tego, która instancja ją wywoła. W takim przypadku instancją wywołującą staje się other.
    // In Object2
      my_method = function()
      {
          show_debug_message(object_get_name(self.object_index));
          show_debug_message(object_get_name(other.object_index));
      }
      
      // In Object1
      Object2.my_method();
    
    Spowoduje to, że instancja najpierw wypisze swoją własną nazwę object ("Object2"), a następnie nazwę object instancji wywołującej ("Object1").
    To samo dotyczy metody, która jest związana z adresem struct.
    Funkcja konstruktora
    Gdy zostanie użyty wewnątrz funkcji konstruktora, other będzie odwoływał się do instancji wywołującej tę funkcję, jednak nie jest to zalecane do ogólnego użytku, ponieważ wszelkie zewnętrzne dane, z których konstruktor musi korzystać, powinny być przekazywane jako argumenty.
     
  
  all
  
    
      
        
          Słowo kluczowe
          Opis
          wartość
        
        
          all
          Wszystkie instancje aktualnie aktywne w serwisie room.
             -3
        
      
    
     
    To słowo kluczowe służy do poinformowania GameMaker Studio 2, że funkcja ma być zastosowana lub sprawdzona we wszystkich aktywnych instancjach w obrębie room (instancje wyłączone nie będą sprawdzane ani udostępniane). Nie można używać all do uzyskiwania dostępu do zmiennych lub ustawiania ich w innych instancjach przy użyciu metody punktowej (zobacz tutaj), ale można go użyć przy wywołaniu with()na przykład:
    with (all)
      {
          speed = 0;
      }
    Powyższy kod ustawi prędkość wszystkich instancji w room na 0. Można także użyć all w funkcjach, aby na przykład skierować lub sprawdzić wszystkie instancje w room:
    // Check a point for any active instance in the room
      inst = instance_position(mouse_x, mouse_y, all);         
      
      // Check all instances for a collision along a line
      if collision_line(x, y, mouse_x, mouse_y, all, false, true) {}
      
      // Add all instances in the room into a motion planning grid
      mp_grid_add_instances(grid, all, false);
    
    all jest bardzo użytecznym słowem kluczowym i może być używane w wielu sytuacjach w kodzie i działaniach, często zmniejszając ilość kodu, który trzeba napisać, aby osiągnąć pożądany efekt.
     
  
  noone
  
    
      
        
          Słowo kluczowe
          Opis
          wartość
        
        
          noone
          Nie ma żadnego przypadku.
             -4
        
      
    
    Może się to wydawać dziwne, ale wiele razy podczas programowania gier pojawia się potrzeba sprawdzenia, czy w danej lokacji, w danej kolizji itp. nie ma żadnych instancji. W takich przypadkach użyjesz tego słowa kluczowego, aby sprawdzić, czy nic nie ma, na przykład tak:
    if instance_nearest(x, y, obj_enemy) != noone
      {
          //do something as there is an enemy instance near
      }
    W tym przykładzie funkcja instance_nearest() zwróci albo noone, albo unikatowy identyfikator najbliższej znalezionej instancji. Zasadniczo za każdym razem, gdy musisz sprawdzić, czy istnieje jakaś instancja, możesz oczekiwać, że zwrócona zostanie albo noone, albo unikalny identyfikator instancji.
     
  
   
   
   
  
    
      
        Powrót: Przegląd GML
        Następny: Kolejność oceniania
      
    
    © Copyright YoYo Games Ltd. 2022 Wszystkie prawa zastrzeżone.
  
  
  

