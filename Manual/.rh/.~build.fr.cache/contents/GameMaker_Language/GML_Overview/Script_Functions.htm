
  
  Funkcje i zmienne skryptowe
  Zasoby skryptowe to zbiór jednej lub więcej funkcji lub zmiennych zdefiniowanych przez użytkownika, które użytkownik zapisuje jako fragmenty kodu w Edytorze skryptów. Funkcje zdefiniowane w witrynie script mogą rozwiązywać wyrażenia, zwracać wartości lub robić wszystko inne, na co pozwala witryna GameMaker Language, podobnie jak wbudowane funkcje runtime.
  Funkcji skryptowych należy używać, gdy mamy blok kodu, który jest używany w więcej niż jednym miejscu lub object, lub gdy chcemy, aby blok kodu był używany w wielu objects w sposób modułowy. Używanie scripts do definiowania funkcji oznacza, że można zmienić funkcję tylko raz, gdy jest to wymagane, a zmiana zostanie "odebrana" przez każdy object, który ma wywołanie tej funkcji.
  Skrypty mogą być również bardzo przydatne z organizacyjnego punktu widzenia, ponieważ umożliwiają tworzenie grup funkcji należących do określonej kategorii - na przykład możesz mieć kilka funkcji związanych z kolizjami między instancjami w swojej grze, więc utworzysz "Collision_Functions" script i będziesz przechowywać w nim wszystkie te funkcje razem.
  Zobacz także: Funkcje skryptu a metody
  Tworzenie funkcji
  Podczas tworzenia strony script zawierającej funkcje, funkcje muszą być utworzone w następujących formatach:
  function name( parameter1, parameter2, ... )
      {
        statement1;
        statement2;
        ...
    }
  
  lub:
  name = function( parameter1, parameter2, ... )
    {
        statement1;
        statement2;
        ...
    }
  
  Aby utworzyć funkcję w GML Visual, użyj polecenia Declare A New Function. Włącz jej opcję "Temp", aby utworzyć zmienną metody (druga składnia pokazana powyżej).
  Generalnie jednak dla funkcji script należy używać pierwszej formy, ponieważ definiuje ona funkcję jako specyficzną funkcję script, co oznacza, że będzie ona miała zasięg globalny , będzie miała przypisany indeks skryptu i nie będzie wymagała prefiksu global do jej identyfikacji, ponieważ kompilator rozpozna ją jako funkcję script.
  Użycie drugiej formy spowoduje wygenerowanie zmiennej metody o zasięgu globalnym i jako taka nie zostanie rozpoznana jako funkcja script przez IDE i będzie wymagała użycia prefiksu global przy odwoływaniu się do niej w kodzie.
  UWAGA Można to sprawdzić, używając obu formularzy w witrynie script, a następnie wywołując na każdym z nich funkcję runtime typeof(). Jedna z nich zostanie zaklasyfikowana jako "liczba" - ponieważ zwraca identyfikator indeksu script - a druga jako "metoda".
  Parametry/Argumenty
  Można zdefiniować własne parametry/argumenty funkcji, które będą dostępne dla funkcji jako zmienne lokalne i mogą być użyte w dowolnym celu w ramach danej funkcji:
  function move(spd, dir)
    {
        speed = spd;
        direction = dir;
    }
  Funkcja ta pobiera dwa argumenty i przypisuje ich wartości do zmiennych speed i direction instancji. Można ją teraz wywoływać jak każdą inną funkcję runtime i przekazywać do niej argumenty:
  var _mouse_dir = point_direction(x, y, mouse_x, mouse_y);
    
    move(4, _mouse_dir);
  
  Argumenty opcjonalne
  Jeśli argument nie zostanie przekazany do funkcji, jego wartością będzie undefined. Można tego użyć do zdefiniowania argumentów opcjonalnych i sprawdzenia, czy argument został przekazany, czy nie, poprzez sprawdzenie, czy jest równy undefined. Można jednak również jawnie zdefiniować wartość domyślną dla argumentu, która zostanie użyta zamiast undefined, gdy nie zostanie przekazany.
  Taką wartość domyślną można przypisać do parametru za pomocą znaku równości (=), czyniąc z niej zmienną opcjonalną:
  function move(spd, dir = 90)
    {
        speed = spd;
        direction = dir;
    }
  Jeśli argument dir nie zostanie podany podczas wywoływania powyższej funkcji, jego wartość będzie domyślnie równa 90, co spowoduje przesunięcie instancji w górę.
  WSKAZÓWKA W wywołaniach funkcji można pominąć argumenty, które domyślnie będą miały wartość undefined (lub wartość domyślną dla tego argumentu określoną przez funkcję).
    
    Na przykład wpisanie adresu my_func(0,,,1) jest równoznaczne z wpisaniem adresu my_func(0, undefined, undefined, 1).
  
  
  Domyślną wartością zmiennej opcjonalnej może być wyrażenie, dlatego definiując zmienną opcjonalną, można na przykład używać zmiennych i wywoływać funkcje. Należy pamiętać, że takie wyrażenie zostanie wykonane tylko wtedy, gdy w wywołaniu funkcji nie zostanie podany jego opcjonalny argument. Zobacz poniższy przykład funkcji logowania:
  function log(text = "Log", object = object_index, time = date_datetime_string(date_current_datetime()))
    {
        var _string = "[" + string(time) + "] ";
        _string += object_get_name(object) + ": ";
        _string += text;
        
        show_debug_message(_string);
    }
  Funkcja ta przyjmuje trzy argumenty, przy czym pierwszy argument jest domyślnie stałą string, drugi argument jest domyślnie zmienną instancji (w zakresie instancji wywołującej), a trzeci argument jest domyślnie wyrażeniem wywołującym funkcję pobierającą bieżącą datę i godzinę. Funkcję tę można teraz wywołać z maksymalnie trzema argumentami, jak widać na poniższym przykładzie:
  log();
    // Prints: [09-Jun-21 12:34:37 PM] Object1: Log
    
    log("Player Shot", obj_player, 10);
    // Prints: [10] obj_player: Player Shot
  
  JSDoc
  Zalecamy również dodawanie komentarzy określających właściwości funkcji (więcej informacji na ten temat znajduje się w rozdziale poświęconym komentarzom JSDoc ), tak aby prosta strona script wyglądała następująco:
  /// @function                 log(message);
    /// @param {string}  message  The message to show
    /// @description              Show a message whenever the function is called.
    
    function log(message)
    {
        show_debug_message(message);
    }
  
  Dodatkowe funkcje dla strony script można dodawać w formacie przedstawionym powyżej, jedna po drugiej, w obrębie strony script asset.
  
  Wartość zwracana
  Funkcje w scripts mogą również zwracać wartość, tak samo jak funkcje runtime, i jako takie mogą być używane w wyrażeniach. W tym celu należy użyć return wyrażenie:
  return <expression>
  Należy zauważyć, że instrukcja return wykonanie funkcji kończy się wraz z instrukcją returnco oznacza, że każdy kod, który pojawi się po wywołaniu return , nie zostanie wykonany. Oto krótki przykład funkcji o nazwie "sqr_calc", która oblicza kwadrat dowolnej wartości, która zostanie jej przekazana, a w przypadku gdy podana wartość nie jest liczbą rzeczywistą, używa return do wcześniejszego zakończenia działania funkcji, tak że właściwe obliczenia nigdy nie zostaną wykonane:
  /// @function           sqr_calc(val);
    /// @param {real}  val  The value to calculate the square of
    /// @description        Calculate the square of the given value
    
    function sqr_calc(val)
    {
        if !is_real(val)
        {
            return 0;
        }
    
        return (val * val);
    }
  
  Zwróć uwagę, że jeśli utworzysz funkcję script bez wartości zwracanej, a następnie w swoim kodzie sprawdzisz, czy jest ona zwracana, domyślnie otrzymasz wartość undefined.
  Aby wywołać funkcję script z wnętrza kodu, wystarczy użyć jej w taki sam sposób, jak w przypadku wywoływania dowolnej funkcji runtime - to znaczy napisać nazwę funkcji z wartościami parametrów w nawiasach. Tak więc powyższy adres script można by wywołać w następujący sposób:
  if keyboard_check_pressed(vk_enter)
    {
        val = scr_sqr(amount);
    }
  UWAGA: Podczas używania własnych funkcji z witryny scripts w edytorze kodu można nacisnąć przycisk  lub kliknąć środkowym przyciskiem myszy  na nazwie funkcji, aby otworzyć stronę script, która ją zawiera, do bezpośredniej edycji.
  Nazwy skryptów a nazwy funkcji
  Ważne jest, aby zrozumieć, że nazwy script są niezależne od funkcji, które zawierają, więc możesz nazywać swoje scripts w bardziej "zdroworozsądkowy" sposób, np. wszystkie funkcje AI mogą być umieszczone w script "Enemy_AI" (zgodnie ze standardową konwencją nazewnictwa asset, polegającą na stosowaniu znaków alfanumerycznych i tylko znaku "_"). Jednak w grze nadal możesz wywoływać scripts - i możesz nazwać scripts tak samo, jak funkcję, którą w niej definiujesz - co może powodować problemy ze względu na sposób, w jaki GameMaker przechowuje odwołania do asset. Aby podać przykład, rozważmy następujący kod, wywołany z instancji:
  function indirectCall(func, arg)
    {
        func(arg);
    }
    
    indirectCall(myscript, arg);
  
  Powyższy kod próbuje wywołać funkcję script o nazwie "myscript" wewnątrz metody, co w tym przypadku nie powiedzie się. Dzieje się tak dlatego, że funkcja in-line tak naprawdę używa indeksu dla script asset, a nie wywołuje funkcji script - np. jeśli indeks script ma wartość "4", funkcja wywołuje 4(arg);, co jest bez sensu. Zamiast tego kod powinien być skonstruowany w jeden z dwóch poniższych sposobów:
  function indirectCall(func, arg)
    {
        func(arg);
    }
    
    indirectCall(method(undefined, myscript), arg);
    
    // OR
    
    function indirectCall(func, arg)
    {
        script_execute(func, arg);
    }
    
    indirectCall(myscript, arg);
  
  Należy o tym pamiętać, zwłaszcza w przypadku starszych projektów, w których scripts zawiera jedną funkcję, a jej nazwa jest taka sama jak nazwa script. Jednak naprawdę nie należy tego robić, a adresy scripts powinny być nazywane niezależnie od funkcji, które zawierają.
   
  Zakres scenariusza
  To prowadzi nas do ostatniej i najważniejszej rzeczy, jaką należy wiedzieć o scripts i zawartych w nich funkcjach: scripts są parsowane na poziomie globalnym i będą kompilowane na samym początku gry. Oznacza to, że technicznie wszystkie funkcje w script są "niepowiązanymi" zmiennymi metod, a wszelkie zmienne zadeklarowane poza funkcją w script będą uważane za zmienne globalne. Na przykład, rozważmy następujący skrypt:
  function Foo()
    {
        // Do something
    }
    blah = 10;
    function Bar()
    {
        // Do something else
    }
  W powyższym przypadku zdefiniowane zostały nie tylko funkcje Foo i Bar, ale także zmienna blah i wszystkie one są uważane za utworzone w zakresie globalnym. Funkcje te nie potrzebują słowa kluczowego global, aby zostały rozpoznane, ponieważ kompilator rozumie, że te funkcje są częścią script, ale gdybyś chciał uzyskać dostęp do blah, musiałbyś to zrobić:
  val = global.blah;
  Zalecamy jednak, aby zawsze wyraźnie wpisywać zmienne globalne podczas ich tworzenia w scripts, aby uniknąć późniejszych problemów. Scripts to także idealne miejsce do definiowania makr i enumów(stałych), ponieważ dodanie ich do script poza funkcją oznacza także, że zostaną one utworzone do użycia przed uruchomieniem kodu gry. Poniżej znajduje się przykład strony script, która tworzy różne wartości zakresu globalnego dla gry:
  /// Initialise All Global Scope Values And Constants
    global.player_score = 0;
    global.player_hp = 100;
    global.pause = false;
    global.music = true;
    global.sound = true;
    
    enum rainbowcolors
    {
        red,
        orange,
        yellow,
        green,
        blue,
        indigo,
        violet
    }
    
    #macro weapon_num 3
    #macro weapon_gun 0
    #macro weapon_bomb 1
    #macro weapon_knife 2
  
  Zwróć uwagę, że wszystkie te stałe są ustawiane poza wywołaniem funkcji, co oznacza, że zostaną zainicjowane przed wszystkim innym i w zakresie globalnym . Oznacza to, że jeśli chcesz użyć skryptu do zainicjowania zmiennych na poziomie instancji , musisz zawrzeć je w funkcji, na przykład:
  /// @function                init_enemy();
    /// @description             Initialise enemy instance vars
    
    function init_enemy()
    {
        hp = 100;
        dmg = 5;
        mana = 50;
    }
  
  Tak więc strony scripts można używać do generowania makr, enumów i zmiennych globalnych przed rozpoczęciem gry, aby były gotowe do użycia w dowolnym momencie, a także do tworzenia "niepowiązanych" metod (funkcji zdefiniowanych przez użytkownika), których można używać w grze jak funkcji GML runtime.
  Ostatnia uwaga dotycząca funkcji script jest taka, że jeśli tworzysz funkcje dla sieci Web (tzn. dla HTML5), istnieje dodatkowy protokół funkcji, którego można użyć podczas dodawania funkcji do scripts, polegający na poprzedzeniu nazwy funkcji znakiem gmcallback_, na przykład:
  gmcallback_create_button
  Użycie powyższej nazwy funkcji oznacza, że funkcja gmcallback_create_button() nie będzie ukryta i będzie można jej używać w JavaScript extensions oraz w innych miejscach gry, na przykład przy użyciu funkcji clickable_* funkcji.
  Zmienne statyczne
  Funkcje mogą również korzystać ze zmiennych statycznych, które zachowują swoje wartości podczas każdego wywołania funkcji. Więcej informacji na ten temat można znaleźć na tej stronie.
   
   
  
    
      
        Powrót: Przegląd GML
        Następny: Zmienne metody
      
    
    © Copyright YoYo Games Ltd. 2022 Wszystkie prawa zastrzeżone.
  
  
  

