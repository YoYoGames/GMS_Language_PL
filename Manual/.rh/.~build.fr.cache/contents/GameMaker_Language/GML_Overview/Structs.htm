
  
  Struktury i konstruktory
   Struktura to zmienna, która przechowuje kolekcję innych zmiennych. Zmienne przechowywane na stronie struct mogą być dowolnego typu danych wymienionych wcześniej, a zmienne te można odczytywać i zapisywać po wstępnej deklaracji struct. Można również dodawać kolejne zmienne do strony struct po jej zadeklarowaniu.
  Zmienne używane w struct powinny być zgodne ze zwykłym schematem nazewnictwa zmiennych, tzn.: nie mogą zaczynać się od liczby i powinny składać się tylko ze znaków alfanumerycznych i znaku podkreślenia "_". Należy również pamiętać, że zawartość struct jest niezależna od instancji lub funkcji, która ją utworzyła, i jako taka może - jeśli chcesz - używać wbudowanych nazw zmiennych, takich jak image_index lub x i y.
  Po początkowym utworzeniu, structs nie ma żadnego narzutu na przetwarzanie danych w czasie swojego istnienia, ale zajmuje miejsce w pamięci. Składnia strony struct jest następująca:
  <variable> =
    {
        <variable> : <value>,
        <variable> : <value>,
        etc...
    };
  
  Przykładem tego w praktyce może być:
  mystruct =
    {
        a : 20,
        b : "Hello World"
    };
  Powyższy kod tworzy zakres instancji struct w zmiennej mystruct i wypełnia ją pewnymi wartościami (structs może być tworzony w zakresie lokalnym, instancji i globalnym, tak jak każda inna zmienna - więcej informacji na ten temat można znaleźć w rozdziale Zmienne i zakres zmiennych). Zauważ, że nie musisz wypełniać zawartości struct, gdy jest ona tworzona na początku, i możesz po prostu utworzyć pustą struct, wykonując tę czynność:
  mystruct = {};
  Do tej strony struct można później dodać kolejne elementy w kodzie gry. Poniżej znajduje się przykład strony struct z różnymi zmiennymi i typami danych:
  var _xx = 100;
    mystruct =
    {
        a : 10,
        b : "Hello World",
        c : int64(5),
        d : _xx + 50,
        e : function(a, b)
            {
                return a + b;
            },
        f : [ 10, 20, 30, 40, 50 ],
        g : image_index
    };
  W powyższym kodzie można również zdefiniować metody i używać funkcji runtime w structs, a także używać zmiennych lokalnych i zmiennych instancji w deklaracji struct.
  Zmienne instancji w deklaracji Struct?
  Na przykład w powyższym przykładzie widać, że zmienna struct "g" jest ustawiana na image_index, która jest zmienną instancyjną. Mogłoby się wydawać, że w tym przypadku trzeba użyć słowa kluczowego other, aby uzyskać zmienną instancji, ale nie jest to konieczne. Zasadniczo, gdy definiujemy struct, wszystkie zmienne członkowskie po lewej stronie dwukropka ":" są zmiennymi struct, a wartości i zmienne po prawej stronie wykorzystują zakres tego, co definiuje struct (w tym przypadku instancję). 
  Aby to zilustrować, posłużymy się prostym przykładem. Powiedzmy, że chcemy zdefiniować stronę struct ze zmiennymi "x" i "y" i chcemy je ustawić na "x" i "y" instancji definiującej stronę struct. W praktyce kod wyglądałby tak:
  mystruct =
    {
        x : x,
        y : y
    };
  W powyższym kodzie zmienne członkowskie struct x i y są ustawiane na wartości przechowywane w zmiennych instancji x i y, ponieważ prawa strona dwukropka ":" odnosi się do instancji, która definiuje struct. Warto zauważyć, że oznacza to, iż nie można używać zmiennych członkowskich struct do definiowania kolejnych zmiennych w ramach deklaracji struct. Na przykład poniższa sytuacja spowodowałaby błąd:
  mystruct =
    {
        a : 10,
        b : 10,
        c : a + b
    }
  Błąd występuje, ponieważ zmienne a i b są w rzeczywistości obliczane w zakresie tego, co definiuje struct (znajdują się po prawej stronie dwukropka ":"), a nie są definiowane w samym struct.
  WAŻNE! Nie można używać żadnych wbudowanych global zmiennych zakresu jako nazw członków struct, np.: game_id lub fps. Pełną listę tych zmiennych globalnych można znaleźć na następnej stronie:
  
    Zmienne zabronione w strukturze
  
  Po zdefiniowaniu adresu struct można uzyskać dostęp do danych w nim zawartych, używając notacji "punktowej", jak poniżej:
  mystruct =
    {
        a : 20,
        b : "Hello World"
    }
    
    mystring = mystruct.b + string(mystruct.a);
  
  Można również wykonywać operacje na zmiennych w ramach witryny struct lub używać ich w funkcjach, podobnie jak w przypadku każdej innej zmiennej. Na przykład:
  mystruct.a += 1;
    mystruct.b = mystruct.a + 20;
    mydir = point_direction(mouse_x, mouse_y, mystruct.xx, mystruct.yy);
  Wreszcie, w witrynie structs mogą być zagnieżdżone inne witryny structs, jak na przykład ta:
  mystruct =
    {
        a :
        {
            aa : "This is an example"
        },
        b :
        {
            bb : "And another one"
        },
    };
  Aby uzyskać dostęp do takich zagnieżdżonych stron structs, należy nadal używać notacji punktowej, jak poniżej:
  var _str = mystuct.a.aa + " " + mystruct.b.bb;
    show_debug_message(_str);
  Innym sposobem dostępu do danych w witrynie struct jest użycie funkcji with() funkcji. Na przykład można to zrobić tak:
  with(mystruct)
    {
        a += other.x;
    }
  Użycie with() zmienia zakres kodu na podany struct, gdzie można manipulować zmiennymi członkowskimi w zakresie struct. Zauważ, że w przykładzie używamy również słowa kluczowegoother . Działa to tak samo jak w instancji przy użyciu with() i spowoduje odwołanie do instancji (lub struct), w której aktualnie jest wykonywany blok kodu.
  Gdy dana strona struct nie jest już potrzebna, można ją usunąć z pamięci za pomocą operatora delete co spowoduje, że flags struct będzie mógł zostać odśmiecony. Nie jest to ściśle wymagane, ponieważ odśmiecacz może to zrobić automatycznie, jeśli w kodzie nie ma już odwołań do struct, ale jest to dobra praktyka i zalecamy jej stosowanie (na przykład wywołanie delete w zdarzeniu Clean Up instancji, aby wyraźnie powiedzieć odśmiecaczowi, że zakres instancji struct ma zostać usunięty). Oto przykład:
  // Create event
    mystruct =
    {
        pos_x : x,
        pos_y : y,
        count : 1000
    };
    
    // Clean Up event
    delete mystruct;
  
  Funkcje konstruktora
  Można także używać funkcji lub metod skryptu do tworzenia funkcji, które mogą być używane do generowania nowych structs, co wymaga użycia słowa kluczowego constructor dla funkcji oraz operatora new podczas tworzenia struct z takiej funkcji. Zobacz następującą funkcję:
  function Vector2(_x, _y) constructor
    {
        x = _x;
        y = _y;
    
        static Add = function(_vec2)
        {
            x += _vec2.x;
            y += _vec2.y;
        }
    }
  
  Można też użyć składni zmiennej metody:
  Vector2 = function(_x, _y) constructor
    {
        x = _x;
        y = _y;
    
        static Add = function(_vec2)
        {
            x += _vec2.x;
            y += _vec2.y;
        }
    }
  
  Tworzymy tutaj funkcję o nazwie Vector2 i informujemy program GameMaker, że jest to funkcja służąca do tworzenia struktur, dodając słowo kluczowe constructor po jej definicji. Następnie można wywołać tę funkcję konstruktora w następujący sposób:
  v2 = new Vector2(10, 10);
  Zmienna v2 będzie teraz zawierać struct ze zmiennymi x i y oraz static zmienną metodyczną Add.
  W funkcjach konstruktorów można również używać opcjonalnych argumentów:
  function Vector2(_x = 0, _y = 0) constructor
    {
        x = _x;
        y = _y;
    }
  Konstruktor ten będzie teraz używał 0 dla argumentów _x i _y, jeśli nie zostaną one określone podczas wywoływania funkcji. Oznacza to, że można utworzyć nową funkcję Vector2 struct bez konieczności podawania jakichkolwiek argumentów:
  empty_vector = new Vector2();
  Dziedziczenie
  Funkcje utworzone w ten sposób będą również obsługiwać pojedyncze dziedziczenie, tzn. można utworzyć funkcję konstruktora, która inherits dane z innej funkcji konstruktora.
  UWAGA: Podczas pracy z dziedziczeniem nie można używać zmiennych metod do definiowania funkcji konstruktora, a jedynie funkcji script.
  Na przykład powyżej utworzyliśmy funkcję konstruktora Vector2, którą możemy wykorzystać jako "rodzica" dla innej funkcji konstruktora, którą nazwiemy Vector3:
  function Vector3(_x, _y, _z) : Vector2(_x, _y) constructor
    {
        z = _z;
    
        static Add = function( _vec3 )
        {
            x += _vec3.x;
            y += _vec3.y;
            z += _vec3.z;
        }
    }
  
  Jak widać, podczas definiowania funkcji używamy dwukropka ":" do oddzielenia nowego konstruktora od konstruktora rodzica, po którym ma on dziedziczyć. Konstruktor dziecka (Vector3) przekazuje argumenty _x i _y do konstruktora rodzica (Vector2), które są używane do uruchomienia najpierw konstruktora rodzica, a następnie konstruktora dziecka. W ten sposób konstruktor dziecka otrzymuje zmienne rodzica (x i y) i może również definiować własne (z).
  Można również przekazywać stałe wartości do konstruktora nadrzędnego, tak by dany konstruktor potomny zawsze przekazywał te same wartości do konstruktora nadrzędnego:
  function Item(damage) constructor
    {
        my_damage = damage;
    }
    
    function BasicSword() : Item(10) constructor
    {}
    
    var _basic_sword = new BasicSword();
    show_debug_message(_basic_sword.my_damage); // Prints 10
  
  Oznacza to, że obrażenia miecza podstawowego zawsze będą wynosić 10, ponieważ konstruktor przekazuje tę wartość swojemu konstruktorowi nadrzędnemu, niezależnie od tego, jakie są jego własne argumenty.
  Należy zauważyć, że przypisanie domyślnej wartości do argumentu w konstruktorze potomnym spowoduje zastąpienie domyślnej wartości rodzica dla tego argumentu. Zobacz poniższy przykład:
  function Parent(value = 10) constructor
    {
        show_debug_message(value);
    }
    
    function Child(value = 20) : Parent(value) constructor
    {
        show_debug_message(value);
    }
    
    var _child = new Child();
  
  Oba te konstruktory wypiszą 20 do dziennika wyjściowego, ponieważ taka była domyślna wartość argumentu ustawiona przez konstruktor potomny i taka sama wartość została przekazana do konstruktora nadrzędnego.
  Więcej informacji na temat operatorów new i delete można znaleźć na następnych stronach:
  
    new
    delete 
  
  String Output
  Ostatnią rzeczą, o której należy wspomnieć w odniesieniu do structs, jest możliwość zmiany sposobu wyprowadzania danych na konsolę w przypadku debugging. Domyślnie wywołanie funkcji show_debug_message() na stronie struct spowoduje wyświetlenie zawartości strony struct (jak pokazano powyżej). Można jednak dostosować ten komunikat, dodając do struct specjalnie nazwaną metodę o nazwie toString:
  mystruct =
    {
        a : 20,
        b : "Hello World",
    
        toString : function()
        {
            return "This stuct says " + b + ", " + string(a) + " times!";
        }
    }
    show_debug_message(mystruct);
  
  Teraz, gdy zostanie wywołana funkcja show_debug_message(), do wygenerowania danych wyjściowych zostanie użyta metoda toString i - na podstawie powyższego przykładu - otrzymamy:
  This struct says Hello World, 20 times!
  Należy pamiętać, że można również wywołać funkcję string() na referencji struct i użyć jej do wyświetlenia zawartości - lub metody toString - na ekranie, lub zapisać ją do pliku, lub cokolwiek innego, np:
  var _str = string(mystruct);
    draw_text(32, 32, _str);
  Wreszcie, istnieje wiele funkcji runtime, których można użyć na stronie structs, aby uzyskać zmienne, które zawierają, a także kilka innych rzeczy. Można je znaleźć w następującej sekcji:
  
    Funkcje zmienne
  
   
   
   
  
    
      
        Powrót: Przegląd GML
        Następny: Komentowanie kodu
      
    
    © Copyright YoYo Games Ltd. 2022 Wszystkie prawa zastrzeżone.
  
  
  

