
  
  json_parse
  Ta funkcja może być użyta do przetworzenia pliku JSON string (utworzonego wcześniej przy użyciu json_stringify lub z dowolnego poprawnego źródła) i przekształcić go w kolekcję tablic lub structs, gdzie tablica jest odpowiednikiem tablicy JSON, a struct jest odpowiednikiem JSON object. Użytkownik podaje adres string do przetworzenia, a funkcja zwraca tablicę najwyższego poziomu lub struct, którą można wykorzystać w swoim kodzie. Jeśli nie masz pewności co do zawartości JSON, możesz użyć różnych funkcji zmiennych (takich jak typeof() oraz variable_struct_get_names() w przypadku struct), aby sprawdzić zwróconą zawartość. Należy pamiętać, że próba parsowania nieprawidłowej wartości (np.: nie string) spowoduje wyświetlenie błędu w postaci wyjątku.
  Podczas korzystania z tej funkcji należy pamiętać o kilku ważnych rzeczach:
  
    Jeśli dostarczony plik JSON string zawiera undefined jako wartość jakiejkolwiek właściwości, po przetworzeniu zostanie on przekonwertowany na pointer_null.
    Ta funkcja umożliwia wczytywanie tylko plików JSON z maksymalnym ograniczeniem zagnieżdżenia do 128.
  
   
  Składnia:
  json_parse(json)
  
    
      
        ArgumentTyp
        Opis
     
      
        json
        The JSON string to parse
     
    
  
   
  Zwroty:
  Struct or Array
   
  Przykład:
  json = "{\"myObj\": { \"apples\":10, \"oranges\":12, \"potatoes\":100000, \"avocados\":0 }, \"myArray\":[0, 1, 2, 2, 4, 0, 1, 5, 1]}";
    
    data = json_parse(json);
    show_debug_message(data);
  
  Powyższy kod tworzy nowy adres string zawierający poprawny JSON object, a następnie wywołuje adres json_parse() w celu przekształcenia adresu string w adres GML struct. Następnie wypisuje wynik do dziennika debugowania.
  UWAGA Zau ważysz, że w pliku JSON string przed każdym podwójnym cudzysłowem (") znajduje się odwrotny ukośnik(\):
    
   json = "{ \ " myObj
    
    Ma to na celu zapewnienie, że cudzysłów jest odczytywany jako rzeczywisty znak w pliku string, a nie jako część kodu i przedwczesne zamknięcie pliku string. W ten sposób używamy odwrotnego ukośnika do "ucieczki" od podwójnego cudzysłowu.
    
    Jeśli jednak ładujesz JSON z pliku zewnętrznego, nie ma potrzeby uciekania od znaków w tym pliku, a takie postępowanie może spowodować błędy podczas przetwarzania.
  
  
  Po przetworzeniu powyższego pliku JSON string, jeśli znasz jego strukturę, możesz użyć różnych funkcji zmiennych, aby sprawdzić i odczytać jego zawartość:
  data = json_parse(json);
    
    // Check if the struct has myObj variable
    if variable_struct_exists(data, "myObj")
    {
        // Check if it's a struct
        if is_struct(data.myObj)
        {
            // Print all struct members to the log
            var _names = variable_struct_get_names(data.myObj);
            var _str = "";
            for (var i = 0; i < array_length(_names); i++;)
            {
                _str = _names[i] + ": " + string(variable_struct_get(data.myObj, _names[i]));
                show_debug_message(_str);
            }
        }
    }
    
    // Check if the struct has myArray variable
    if variable_struct_exists(data, "myArray")
    {
        // Check if it's an array
        if is_array(data.myArray)
        {
            show_debug_message(data.myArray);
        }
    }
  
  Powyższy kod przetworzy podany plik JSON string, generując następujące dane wyjściowe w konsoli:
  oranges: 12
    potatoes: 100000
    avocados: 0
    apples: 10
    [ 0,1,2,2,4,0,1,5,1 ]
   
   
   
  
    
      
        Powrót: Kodowanie plików
        Następny: base64_encode
      
    
    © Copyright YoYo Games Ltd. 2022 Wszystkie prawa zastrzeżone.
  
  
  

