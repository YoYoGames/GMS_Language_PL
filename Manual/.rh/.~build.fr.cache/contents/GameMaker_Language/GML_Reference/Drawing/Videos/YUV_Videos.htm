
  Wideoklipy YUV
  Platformy, które używają formatu kolorów YUV dla filmów wideo, wymagają dodatkowych czynności podczas rysowania tych filmów. Polega to na użyciu strony shader do narysowania dwóch powierzchni na prymitywnym quadzie.
  Przeczytaj najpierw stronę video_draw(), aby dowiedzieć się, jakie dane zwraca ta funkcja w przypadku wideo YUV, a następnie kontynuuj czytanie poniżej, aby uzyskać instrukcje dotyczące używania tych danych do rysowania wideo.
  YUV Shader
  Utwórz w swoim projekcie stronę shader asset i zastąp jej kod Fragment Shader (.fsh) następującym kodem:
  //
// CUSTOM fragment shader do obsługi zawartości YUV
//
varying vec2 v_vTexcoord;
varying vec4 v_vColour;
jednolity sampler2D v_chroma;
const float x = 1,164383;
const float y = 1.138393;
const float z = 1.138393;
const vec3 src_bias = vec3(16.0 / 255.0, 128.0 / 255.0, 128.0 / 255.0);
const mat3 src_xform = mat3(1.000000 * x, 0.000000 * y, 1.57480000 * z,
                            1.000000 * x, -0.18732427 * y, -0.46812427 * z,
			    1.000000 * x, 1.85560000 * y, 0.000000 * z);
void main()
{
    float yy = texture2D(gm_BaseTexture, vec2(v_vTexcoord.x, v_vTexcoord.y)).r;
    vec2 cbcr = texture2D(v_chroma, vec2(v_vTexcoord.x, v_vTexcoord.y)).rg;
    vec3 yuv = vec3(yy, cbcr);
    yuv -= src_bias;
    yuv *= src_xform;
    gl_FragColor = vec4(yuv, 1.0);
}
  

  Pobierz próbnik
  W zdarzeniu Create (Utwórz) na stronie object należy pobrać identyfikator próbnika v_chroma shader uniform, tylko jeśli obraz wideo jest w formacie YUV:
  var _format = video_get_format();
if (_format == video_format_yuv)
{
    videochromasampler = shader_get_sampler_index(shader_YUV, "v_chroma");
}

  Film rysunkowy
  W zdarzeniu Draw programu object wywołaj video_draw() i jeśli pierwsza pozycja tablicy jest równa 0 (czyli film jest odtwarzany), narysuj film.
  W poniższym kodzie używamy instrukcji switch na funkcji video_get_format(). Jeśli w filmie używany jest format RGBA, to powierzchnia jest po prostu rysowana na pozycji [1] tablicy.
  Jeśli obraz wideo jest w formacie YUV, wykorzystuje stronę shader do narysowania dwóch powierzchni (w pozycjach [1] i [2]) na prymitywnym quadzie.
  var _data = video_draw();
if(_data[0] == 0)
{
	switch(video_get_format())
	{
		case video_format_rgba:
			var _surf = _data[1];
			draw_surface(_surf,0,0);
		break;
	
		// #### YUV PART HERE ####
		case video_format_yuv:
			var _surf = _data[1];
			var _chromasurf = _data[2];
			if(surface_exists(_surf) and surface_exists(_chromasurf))
			{
				shader_set(shader_YUV);
			
				var _tex_id = surface_get_texture(_surf);
				var _chroma_tex_id = surface_get_texture(_chromasurf);
				texture_set_stage(videochromasampler, _chroma_tex_id);
				gpu_set_texfilter(false);
			
				draw_primitive_begin_texture(pr_trianglestrip, _tex_id);
			        draw_vertex_texture(0, 0, 0, 0);
				draw_vertex_texture(surface_get_width(_chromasurf), 0, 1, 0);
				draw_vertex_texture(0, surface_get_height(_chromasurf), 0, 1);
				draw_vertex_texture(surface_get_width(_chromasurf), surface_get_height(_chromasurf), 1, 1);
				draw_primitive_end();
			
				gpu_set_texfilter(true);
				shader_reset();
			}
		break;
	}
}
  
  Kod w przypadku video_format_yuv: wykonuje następujące czynności:
  
    Zbiera powierzchnię wideo(_surf) i powierzchnię chroma(_chromasurf)
    Upewnia się, że istnieją, używając surface_exist()
      
        Ustawia shader na shader_YUV (czyli nasz nowo utworzony YUV shader).
        Uzyskuje adres textures obu powierzchni.
        Przypisuje adres texture powierzchni chromatycznej do próbnika, który został pobrany w zdarzeniu Create.
        Wyłącza filtrowanie texture.
        Rozpoczyna rysowanie prymitywu trójkątnego paska z przypisanym do niego adresem texture powierzchni wideo
        Rysuje prostokąt pokrywający powierzchnię wideo, używając szerokości i wysokości powierzchni chromatycznej dla tego prostokąta
        Kończy prymityw
        Ponownie włącza filtrowanie texture i resetuje shader.
      
    
  
  Tutaj główna powierzchnia wideo jest rysowana przez prymityw, a powierzchnia chromatyczna jest do niej wtapiana przez shader. Z tego powodu texture powierzchni chromatycznej został przekazany do shader za pomocą samplera.
   
   
   
  
    
      
        Wstecz: Odtwarzanie wideo
        Next: video_set_volume
      
    
    © Copyright YoYo Games Ltd. 2022 Wszystkie prawa zastrzeżone.
  
  
  

