
  
  Odbiór śmieci
   GameMaker Studio 2 Garbage Collector istnieje, ponieważ metody mogą być przekazywane na stos i pozostawiane bez odniesienia, podobnie jak structs i kilka innych rzeczy, co z kolei spowodowałoby wyciek pamięci, gdyby nie zostały w jakiś sposób "wyczyszczone". W tym miejscu do akcji wkracza garbage collector, który działa w tle gry, zbierając wszystko, co zostało pozbawione odniesienia, i utrzymując optymalne wykorzystanie pamięci. Kiedy mówimy o czymś, co nie ma odniesienia, odnosimy się do struct lub funkcji, która nie jest połączona (nie musi być bezpośrednio, ale poprzez łańcuch innych zmiennych) ze zmienną globalną lub zmienną instancji obiektu. Należy również pamiętać, że funkcje zdefiniowane w scripts na stronie IDE również nie są gromadzone, ponieważ są one niejawnie globalne.
  UWAGA: Należy pamiętać, że takie rzeczy jak powierzchnie, struktury danych, buffers i inne zasoby dynamiczne nie są zbierane jako śmieci i mają swoje własne funkcje destroy, które czyszczą związaną z nimi pamięć. Zasadą jest, że jeśli cokolwiek, co zostanie utworzone w czasie uruchamiania, ma funkcję destroy, to nie będzie odśmiecane i trzeba będzie się tym zająć samodzielnie w kodzie. Wyjątkami są sequences, animation curves oraz instancje, które również wymagają odśmiecania, ale nadal muszą mieć wywoływaną funkcję destroy.
  Odśmiecanie, z którego korzysta witryna GameMaker Studio 2, ma charakter "pokoleniowy". Oznacza to, że w celu zmniejszenia ilości pracy, jaką trzeba wykonać przy każdej ramce, objects jest podzielony na "generacje". Nowe objects są tworzone w generacji 0, a w miarę starzenia się są przenoszone do starszych generacji. Ogólna idea jest taka, że obiekty objects, które istnieją przez jakiś czas, nie muszą być ciągle sprawdzane, czy powinny zostać usunięte, ale mogą być sprawdzane rzadziej (zauważ, że "obiekty" odnoszą się tu do wszystkiego, co może zostać wyrzucone na śmietnik, a nie do ogólnych instancji object zdefiniowanych w przeglądarce Asset ). Zauważ, że chociaż system sprawdzania jest generacyjny, faktyczne sprawdzanie odbywa się w sposób "przyrostowy", tak że zamiast usuwać potencjalnie tysiące objects z generacji w jednej ramce - co powoduje duży skok użycia procesora i potencjalnie wpływa na rozgrywkę - każda generacja będzie sprawdzana i w razie potrzeby czyszczenie będzie rozłożone na wiele ramek, dzięki czemu śmieciarz będzie działał częściej, ale będzie wykonywał mniej pracy w każdej ramce (można ustawić docelowy czas, jaki śmieciarz ma spędzić na każdej ramce, używając funkcji gc_target_frame_time()).
  Zasadniczo nie powinno być potrzeby interakcji z systemem zbierania śmieci GameMaker Studio 2 i zazwyczaj wyniki jego działania nie są widoczne, ale niektóre polecenia GML umożliwiają uzyskanie informacji o tym, co robi system zbierania śmieci, oraz wpłynięcie na jego zachowanie w ograniczonym stopniu.
  WAŻNE! Należy pamiętać, że na platformie docelowej HTML5 odśmiecanie jest obsługiwane przez silnik JavaScript, dlatego żadna z poniższych funkcji nie będzie miała wpływu na jego działanie, a funkcja gc_get_stats() zwróci 0 dla wszystkich pól.
  
    gc_enable
    gc_is_enabled
    gc_collect
    gc_target_frame_time
    gc_get_target_frame_time
    gc_get_stats
  
   
  Aby pomóc w określeniu, co i kiedy wymaga odśmiecania, można skorzystać z kilku funkcji, które służą do tworzenia i sprawdzania słabych odwołań do structs. Słabe odwołanie to odwołanie, które nie chroni odwołującej się strony object przed zbieraniem śmieci, a zatem może być użyte do sprawdzenia, czy strona struct jest nadal "żywa" (odwołuje się do niej), czy nie gdzieś w grze. Funkcje dostępne dla słabych odwołań to:
  
    weak_ref_create
    weak_ref_alive
    weak_ref_any_alive
  
   
   
   
  
    
      
        Powrót: Odniesienie do GML
        Następny: Funkcje zmiennych
      
    
    © Copyright YoYo Games Ltd. 2022 Wszystkie prawa zastrzeżone.
  
  
  

